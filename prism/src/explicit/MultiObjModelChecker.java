package explicit;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

import explicit.rewards.MDPRewards;
import parser.type.TypeDouble;
import prism.Point;
import prism.PrismComponent;
import prism.PrismException;
import prism.PrismNotSupportedException;

public class MultiObjModelChecker extends PrismComponent
{
	protected ProbModelChecker mc;
	
	/**
	 * Create a new MultiObjModelChecker, inherit basic state from parent (unless null).
	 */
	public MultiObjModelChecker(ProbModelChecker mc)
	{
		super(mc);
		this.mc = mc;
	}

    /* Multi-objective MDP solver
     * This algorithm is based on "Linear Support for Multi-Objective Coordination Graphs" by Roijers et al.
	 * The part of code for computing new weights in OLS algorithm is modified based the following git hub repo
	 * https://github.com/Svalorzen/morl_guts/blob/master/gp_preference/pymodem/optimistic_linear_support.py
	 * @param model the model of POMDP
     * */
    
    protected StateValues checkExpressionParetoMultiObjMDPWithOLS(Model model, List<MDPRewards> mdpRewardsList, BitSet target, List<MinMax> minMaxList, BitSet statesOfInterest) throws PrismException
    {
    	int numObjs = minMaxList.size();
    	
		// Dummy return value
    	double threshold = 0.00001;
		ArrayList<ArrayList<Double>> partial_CCS = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> partial_CCS_weights = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> w_v_checked = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> vector_checked = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> weights_checked = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> priority_queue = new ArrayList<ArrayList<Double>>();
		HashMap <ArrayList<Double>, ArrayList<ArrayList<Double> >> corner_to_value = new HashMap < ArrayList<Double>, ArrayList<ArrayList<Double>>> ();
		HashMap <ArrayList<Double>, ArrayList<ArrayList<Double> >> value_to_corner = new HashMap < ArrayList<Double>, ArrayList<ArrayList<Double>>> ();
		priority_queue =  initialQueue(minMaxList, corner_to_value, model);

		mainLog.println("****************************************************");

		while(priority_queue.size()>0){
			mainLog.println("+++++++++++");
			mainLog.println("Current Q (weight, priority) Before Pop"+Arrays.toString(priority_queue.toArray()));
			mainLog.println("Current paritial CCS Before Pop"+Arrays.toString(partial_CCS.toArray()));
			mainLog.println("Current paritial CCS weights Before Pop"+Arrays.toString(partial_CCS_weights.toArray()));
			mainLog.println("corner_to_value");

			if(corner_to_value.keySet().size()>0){
				mainLog.println(corner_to_value.keySet().size());
				mainLog.println(corner_to_value.keySet());
				for (Object  key:corner_to_value.keySet()){
					ArrayList<ArrayList<Double>> tp = (ArrayList<ArrayList<Double>>) corner_to_value.get(key);
					mainLog.println(key);
					mainLog.println(tp.size());

					if (tp.size()>0){
						for (int i=0; i< tp.size(); i++){
							mainLog.println(key+" -> "+ Arrays.toString(((ArrayList<Double>) tp.get(i) ).toArray()));
						}
					}
				}
			}
			mainLog.println("value_to_corner");
			if(value_to_corner.keySet().size()>0){
				for (Object  key:value_to_corner.keySet()){
					ArrayList<ArrayList<Double>> tp = (ArrayList<ArrayList<Double>>) value_to_corner.get(key);
					for (int i=0; i< tp.size(); i++){
						mainLog.println(key+" -> "+ Arrays.toString(((ArrayList<Double>) tp.get(i) ).toArray()));
					}
				}
			}
			mainLog.println("+++++++++++");

			ArrayList<Double> w_pop = deQueue(priority_queue);

			mainLog.println("Pop weight with top priority: "+Arrays.toString(w_pop.toArray()));
			mainLog.println("Current Q (weight, priority)  After pop"+Arrays.toString(priority_queue.toArray()));
			
			StateValues sv = mc.checkExpressionWeightedMultiObj(model, w_pop, mdpRewardsList, target, minMaxList, statesOfInterest);
			ArrayList<Double> u = (ArrayList<Double>) sv.getValue(model.getFirstInitialState());
			mainLog.println("Value vector: "+u);
			
			int countNewWeights = 0; //number of weights generated by u


			w_v_checked.add((ArrayList<Double>) w_pop.clone());
			weights_checked.add((ArrayList<Double>) w_pop.clone());
			w_v_checked.add((ArrayList<Double>) u.clone());
			vector_checked.add((ArrayList<Double>) u.clone());

			mainLog.println("w_pop: "+Arrays.toString(w_pop.toArray()));
			mainLog.println("u: "+Arrays.toString(u.toArray()));
			mainLog.println("w_pop*u: "+innerProduct(w_pop,u));
			mainLog.println("w_v_checked"+Arrays.toString(w_v_checked.toArray()));


			//if (!partial_CCS.contains(u)) {
			if (!containsWithError(partial_CCS,u, 1E-5)) {
				if (partial_CCS.size()==0) {// when to compute
					for (int i_queue=0; i_queue<priority_queue.size();i_queue++){
						ArrayList<Double> weight_tp = (ArrayList<Double>) priority_queue.get(i_queue).clone();
						weight_tp.remove(weight_tp.size()-1);
						ArrayList<ArrayList<Double>> current_value_set = (ArrayList<ArrayList<Double>>) corner_to_value.get(weight_tp).clone();
						current_value_set.add(u);
						corner_to_value.put(weight_tp, current_value_set );
						ArrayList<ArrayList<Double>> weight_tp_set =  new ArrayList<ArrayList<Double>> ();
						if(value_to_corner.containsKey(u))
							weight_tp_set = (ArrayList<ArrayList<Double>>) value_to_corner.get(u).clone();
						weight_tp_set.add(weight_tp);
						value_to_corner.put(u,weight_tp_set);
					}
					mainLog.println("add value vector from 1st exterme weights");
					partial_CCS.add((ArrayList<Double>) u.clone());
					partial_CCS_weights.add((ArrayList<Double>) w_pop.clone());
					mainLog.println(partial_CCS.size());
				}
				else {

					mainLog.println("elsess");
					double original_value = innerProduct(adjustWeight(w_pop,minMaxList, model), u);
					double other_prod = innerProduct(adjustWeight(w_pop,minMaxList,model), corner_to_value.get(w_pop).get(corner_to_value.get(w_pop).size()-1));
					if ((original_value - other_prod)>1E-08){

						//remove from value dict
						ArrayList<ArrayList<Double>> existing_value_vectors = corner_to_value.get(w_pop);
						ArrayList<ArrayList<Double>> existing_weights = new ArrayList<ArrayList<Double>> () ;
						for (int i_evv=0; i_evv<existing_value_vectors.size(); i_evv++){
							ArrayList<Double> existing_value_vector = existing_value_vectors.get(i_evv);
							if (value_to_corner.containsKey(existing_value_vector)){
								existing_weights = value_to_corner.get(existing_value_vector);
								for (int j_ew=0; j_ew<existing_weights.size();j_ew++){
									ArrayList<Double> existing_weigth = existing_weights.get(j_ew);
									if ( containsWithError(existing_weights, w_pop, threshold) && (!(w_pop.contains(1.0)))){
										int tp_index = existing_weights.indexOf(w_pop);
										value_to_corner.get(existing_value_vector).remove(tp_index);
									}
								}
							}
						}

						//check obsolete 
						ArrayList<ArrayList<Double>> weight_list = new ArrayList<ArrayList<Double>> ();
						weight_list.add(w_pop);
						ArrayList<ArrayList<Double>> obsolete_list = new ArrayList<ArrayList<Double>> ();
						while (weight_list.size()>0){
							ArrayList<Double> weight = weight_list.get(weight_list.size()-1);
							weight_list.remove(weight_list.size()-1);
							if (corner_to_value.containsKey(weight)){
								existing_value_vectors = (ArrayList<ArrayList<Double>>) corner_to_value.get(weight).clone();
								ArrayList<Double> existing_value_vector = existing_value_vectors.get(existing_value_vectors.size()-1);
								double scalarized_value = innerProduct(existing_value_vector, adjustWeight(weight,minMaxList,model));
								if (original_value>scalarized_value){
									for (int i_evv=0; i_evv<existing_value_vectors.size(); i_evv++){
										existing_value_vector = existing_value_vectors.get(i_evv);
										if (value_to_corner.containsKey(existing_value_vector)){

											mainLog.println("+++++++++corner_to_value");
											for (Object  key:corner_to_value.keySet()){
												ArrayList<ArrayList<Double>> tp = (ArrayList<ArrayList<Double>>) corner_to_value.get(key);
												for (int i=0; i< tp.size(); i++){
													mainLog.println(key+" -> "+ Arrays.toString(((ArrayList<Double>) tp.get(i) ).toArray()));
												}
											}
											mainLog.println("+++++++++value_to_corner");
											for (Object  key:value_to_corner.keySet()){
												ArrayList<ArrayList<Double>> tp = (ArrayList<ArrayList<Double>>) value_to_corner.get(key);
												for (int i=0; i< tp.size(); i++){
													mainLog.println(key+" -> "+ Arrays.toString(((ArrayList<Double>) tp.get(i) ).toArray()));
												}
											}
											ArrayList<ArrayList<Double>> current_weights = value_to_corner.get(existing_value_vector);
											for (int j_cw=0; j_cw<current_weights.size(); j_cw++){
												ArrayList<Double> current_weight = current_weights.get(j_cw);
												if ((!current_weights.equals(weight)) && (obsolete_list.contains(current_weight))){
													weight_list.add((ArrayList<Double>) current_weight.clone());
												}
											}											
										}
									}
									obsolete_list.add((ArrayList<Double>) weight.clone());
								}
							}
						}

						for (int iprint=0; iprint<obsolete_list.size();iprint++){
							mainLog.println("obsolete_list: "+Arrays.toString(obsolete_list.get(iprint).toArray())+"\n");
						}

						///compute new corner
						ArrayList<ArrayList<Double>> boundaries=new ArrayList<ArrayList<Double>>();
						for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
							ArrayList<Double> obsolete_weight = obsolete_list.get(i_obs);
							for (int j_obs=0; j_obs<obsolete_weight.size();j_obs++){
								ArrayList<Double> boundary = new ArrayList<Double> ();
								boundary.add((double) j_obs);
								if (((double) obsolete_weight.get(j_obs)==0) && (!boundaries.contains(boundary)))
									boundaries.add(boundary);
							}
						}

						ArrayList<ArrayList<Double>> old_value_vectors = new ArrayList<ArrayList<Double>>  ();

						for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
							ArrayList<Double> found_weight = obsolete_list.get(i_obs);
							ArrayList<ArrayList<Double>> found_values = corner_to_value.get(found_weight);
							for (int j_fv=0; j_fv<found_values.size(); j_fv++){
								ArrayList<Double> found_value = found_values.get(j_fv);
								mainLog.println("found_value"+Arrays.toString(found_value.toArray()));
								mainLog.println(!old_value_vectors.contains(found_value));
								mainLog.println("u"+Arrays.toString(u.toArray()));
								mainLog.println(!found_value.equals(u));
								if((!old_value_vectors.contains(found_value))&&(!found_value.equals(u))) {
									old_value_vectors.add((ArrayList<Double>) found_value.clone());
								}
							}
						}

						// /*
						old_value_vectors = new ArrayList<ArrayList<Double>>  ();

						for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
							double bestValue = innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, model), partial_CCS.get(0));
							for (int j_partialCSS=0; j_partialCSS < partial_CCS.size(); j_partialCSS++){
								if (innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, model), partial_CCS.get(j_partialCSS))>bestValue){
									bestValue = innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, model), partial_CCS.get(j_partialCSS));
								}
							}
							for (int j_partialCSS=0; j_partialCSS < partial_CCS.size(); j_partialCSS++){
								if (Math.abs(innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, model), partial_CCS.get(j_partialCSS))-bestValue)<1E-06){
									if (old_value_vectors.size()<numObjs){ //if Vs(w) contians fewer than dvalue vecotrs
										old_value_vectors.add((ArrayList<Double>) partial_CCS.get(j_partialCSS).clone());
									}
								}
							}
						}


						for (int i_b=0; i_b<boundaries.size();i_b++){
							old_value_vectors.add((ArrayList<Double>) boundaries.get(i_b).clone());
						}

						for (int iprint=0; iprint<old_value_vectors.size();iprint++){
							mainLog.println("old_value_vectors: "+Arrays.toString(old_value_vectors.get(iprint).toArray())+"\n");
						}

						//compute new points
						//Add to queue
						ArrayList<ArrayList<Double>> subset = new ArrayList<ArrayList<Double>>(); //one kind of combination

						ArrayList<Double> tpp= new ArrayList<Double>();
						tpp.add(1.0);
						tpp.add(1.0);
						for (int i_ojs=0; i_ojs<numObjs-1;i_ojs++){
							subset.add(tpp);
						}

						ArrayList<ArrayList<ArrayList<Double>>> subsets = new ArrayList<ArrayList<ArrayList<Double>>>(); //all combination
						
						mainLog.println("old_value_vectors size"+old_value_vectors.size());
						combinations2(old_value_vectors, numObjs-1, 0, subset, subsets);

						mainLog.println("allsubsets: total number of combinations"+Arrays.toString(subsets.toArray())+subsets.size());
						
						for(int i_subset=0; i_subset<subsets.size();i_subset++){
							ArrayList<ArrayList<Double>> hCCS = new ArrayList<ArrayList<Double>>(); //optimistic hypothetical CCS
							ArrayList<ArrayList<Double>> A = new ArrayList<ArrayList<Double>>();
							ArrayList<Double> augumented_vector = new ArrayList<Double>();
							ArrayList<Double> bound_from_w_obsolete = new ArrayList<Double>();
							ArrayList<ArrayList<Double>> oneCombination =(ArrayList<ArrayList<Double>> ) subsets.get(i_subset).clone();
							for (int j=0; j<oneCombination.size(); j++){
								augumented_vector = (ArrayList<Double>) oneCombination.get(j).clone();
								if (augumented_vector.size()==numObjs){
									hCCS.add((ArrayList<Double>) augumented_vector.clone());
									augumented_vector.add(-1.0);
									A.add(augumented_vector);
								}
								else{
									bound_from_w_obsolete.add((double) augumented_vector.get(0));
								}
							}
							hCCS.add((ArrayList<Double>) u.clone());
							augumented_vector = (ArrayList<Double>) u.clone();
							augumented_vector.add(-1.0);
							A.add((ArrayList<Double>) augumented_vector.clone());

							//simplex constraint
							ArrayList<Double> bound = new ArrayList<Double>();
							for (int i=0; i<numObjs;i++) {
								bound.add(1.0);
							}
							bound.add(0.0);
							A.add(bound);


							// remove column that has bound. (E.g. for weight [0.5,0.5,0], the boundary index is 2, then remove column 2 from A)
							
							for (int i_bf=0; i_bf<bound_from_w_obsolete.size();i_bf++){
								double removeIndex = (double) bound_from_w_obsolete.get(i_bf);
								int remove = (int) removeIndex;
								for (int i_A=0; i_A<A.size(); i_A++){
									A.get(i_A).remove(remove);
								}
							}
							
							ArrayList<Double> b = new ArrayList<Double>();
							for (int i=0; i<A.size()-1; i++) {
								b.add(0.0);
							}
							b.add(1.0);

							ArrayList<Double> w_new = new ArrayList<Double>();
							w_new = linSolver(A,b);
							w_new.remove(w_new.size()-1);

							for (int i_bf=0; i_bf<bound_from_w_obsolete.size();i_bf++){
								double insertIndex = (double) bound_from_w_obsolete.get(i_bf);
								int insert = (int) insertIndex;
								w_new.add(insert,0.0);
							}
							

							Boolean allPositive = true;
							for (int iw=0; iw<w_new.size();iw++){
								if ((double) w_new.get(iw)<0){
									allPositive = false;
								}
							}
							if (!allPositive){
								mainLog.println("Negative... continue");
								continue;
							}

							if (w_new.contains(1.0)){
								mainLog.println("Extreme... continue");
								continue;
							}
							if (w_new.contains(Double.NaN)){
								mainLog.println("NaN... continue");
								continue;
							}
							mainLog.println("generateing new weights by"+Arrays.toString(u.toArray()));
							
							countNewWeights++;
							mainLog.println(countNewWeights+"Number of New weights generated by :"+Arrays.toString(u.toArray()));
							mainLog.println("w_new"+Arrays.toString(w_new.toArray()));
							if (countNewWeights>numObjs)
								mainLog.println("More new weights than expected");

							//////// this is for rounding
							
							double weigth_sum = 0.0;
							for (int iw=0;iw<w_new.size()-1;iw++){
								w_new.set(iw, (double) Math.round((double)w_new.get(iw) * 1000000)/1000000);
								weigth_sum += (double) w_new.get(iw);
							}
							w_new.set(w_new.size()-1, (double) 1-weigth_sum);
							mainLog.println("w_new (sum to 1)"+Arrays.toString(w_new.toArray()));
							

							//update value_to_corner & corner_to_value
							ArrayList<ArrayList<Double>> default_value_vecotrs = new  ArrayList<ArrayList<Double>>();
							default_value_vecotrs.add((ArrayList<Double>) u.clone());
							corner_to_value.put((ArrayList<Double>) w_new.clone(), default_value_vecotrs);

							ArrayList<ArrayList<Double>> new_weights = new  ArrayList<ArrayList<Double>>();
							new_weights.add((ArrayList<Double>) w_new.clone());
							value_to_corner.put(u,new_weights);


							// Add to priority queue
							double priority=1.0;

							mainLog.println("computing priority = "+hCCS.size());
							
							double VCCS = maxValueLP(minMaxList, model, w_new, partial_CCS , partial_CCS_weights, u, w_pop );
							double Vsw = innerProduct(u, adjustWeight(w_new, minMaxList, model));
							priority = Math.abs((VCCS-Vsw)/(VCCS));
							
							
							if (priority > threshold){
								w_new.add(priority);
								priority_queue.add((ArrayList<Double>) w_new.clone());
							}

							//delete obsolete list from priority queue
							for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
								ArrayList<Double> obsolete_weight =  obsolete_list.get(i_obs);
								if (!obsolete_weight.contains(1.0)){
									for (int j_queue=0; j_queue<priority_queue.size(); j_queue++){
										ArrayList<Double> tp_weight = (ArrayList<Double>) priority_queue.get(j_queue).clone();
										tp_weight.remove(tp_weight.size()-1);
										if (tp_weight.equals(obsolete_weight)){
											mainLog.println("Removing obsolete_weight:"+ Arrays.toString(obsolete_weight.toArray()));
											priority_queue.remove(j_queue);
										}
									}
								}
							}
						}
					}
				//
					//add to solution
					partial_CCS.add((ArrayList<Double>) u.clone());
					partial_CCS_weights.add((ArrayList<Double>) w_pop.clone());
				}
			}
			else {
				mainLog.println("Vector already in the partial CCS");

			}
		}
		//mainLog.println("Checked weights and values:"+Arrays.toString(w_v_checked.toArray()));
		//mainLog.println("Pareto Curve by OLS: "+Arrays.toString(partial_CCS.toArray()));
		mainLog.println("ALl weights checked:"+ weights_checked.size());
		HashSet values_OLS = new HashSet();

		for (int iprint=0; iprint<weights_checked.size();iprint++){
			mainLog.print("weight: "+Arrays.toString(weights_checked.get(iprint).toArray())+"; vector: "+Arrays.toString(vector_checked.get(iprint).toArray())+"\n");
		}
		mainLog.println("*********************ParetoCurve by optimal linear solution*******************************");

		for (int iprint=0; iprint<partial_CCS.size();iprint++){
			mainLog.print("weight: "+Arrays.toString(partial_CCS_weights.get(iprint).toArray())+"; vector: "+Arrays.toString(partial_CCS.get(iprint).toArray())+"\n");
			values_OLS.add(innerProduct(partial_CCS_weights.get(iprint),partial_CCS.get(iprint)));

		}
		mainLog.print("#weights: "+partial_CCS_weights.size()+"\n");
		for (int iprint=0; iprint<partial_CCS.size();iprint++){
			mainLog.print(Arrays.toString(partial_CCS_weights.get(iprint).toArray())+"\n");
		}
		mainLog.println("#Pareto Curve points: "+partial_CCS.size()+"\n");
		for (int iprint=0; iprint<partial_CCS.size();iprint++){
			mainLog.print(Arrays.toString(partial_CCS.get(iprint).toArray())+"\n");
		}
		//mainLog.println("scalarized values OLS:"+values_OLS.size());
		//mainLog.println(values_OLS);
				
		// Return Pareto curve as Point list
		List<Point> points = new ArrayList<>();
		for (ArrayList<Double> paretoPoint : partial_CCS) {
			Point point = new Point(paretoPoint.size());
			for (int dim = 0; dim < paretoPoint.size(); dim++) {
				point.setCoord(dim, paretoPoint.get(dim));
			}
			points.add(point);
		}
		Object array[] = new Object[model.getNumStates()];
		array[model.getFirstInitialState()] = points;
		return StateValues.createFromObjectArray(TypeDouble.getInstance(), array, model);
    }
    
    protected StateValues checkExpressionParetoMultiObjMDPWithRandomSampling(Model model, List<MDPRewards> mdpRewardsList, BitSet target, List<MinMax> minMaxList, BitSet statesOfInterest) throws PrismException
    {
    	int numObjs = minMaxList.size();
    	
		// Dummy return value
		HashSet<List<Double>> paretoCurve = new HashSet<>();

		// Random sampling:
		ArrayList<ArrayList<Double>> w_v_checked_rs = new ArrayList<ArrayList<Double>>();
		double rs =1;
		if (rs>0){
			if (numObjs == 3) {
				for (int i =0;i<11;i++){
					double w1 = ((double) i )*0.1;
					for (int j=0; j<11; j++){
						double w2= ((double) j )*0.1;
						if (w1+w2<=1){
							double w3= 1-w1-w2;
							ArrayList<Double> weights = new ArrayList<>();
							weights.add(w1);
							weights.add(w2);
							weights.add(w3);
							StateValues sv = mc.checkExpressionWeightedMultiObj(model, weights, mdpRewardsList, target, minMaxList, statesOfInterest);
							ArrayList<Double> point = (ArrayList<Double>) sv.getValue(model.getFirstInitialState());
							mainLog.println("weights: "+Arrays.toString(weights.toArray()));
							mainLog.println("Points: "+Arrays.toString(point.toArray()));
							paretoCurve.add(point);
							if((!containsWithError(w_v_checked_rs,point,1E-06)) || true){
								w_v_checked_rs.add(weights);
								w_v_checked_rs.add(point);
							}
							mainLog.println("\nPareto curve: " + paretoCurve);
							mainLog.println("w_v_checked: "+Arrays.toString(w_v_checked_rs.toArray()));
						}
					}
				}		
				mainLog.println("\n finishing Pareto curve: " + paretoCurve);
				mainLog.println("finishing w_v_checked: "+Arrays.toString(w_v_checked_rs.toArray()));
				//return StateValues.createFromSingleValue(TypeDouble.getInstance(), 0.0, model);
			}
			if (numObjs == 2) {		
				//HashSet<List<Double>> paretoCurve = new HashSet<>();
				int numPoints = 10;
				for (int i = 0; i <= numPoints; i++) {
					double w1 = ((double) i) / numPoints;
					double w2 = 1.0 - w1;
					ArrayList<Double> weights = new ArrayList<>();
					weights.add(w1);
					weights.add(w2);

					StateValues sv = mc.checkExpressionWeightedMultiObj(model, weights, mdpRewardsList, target, minMaxList, statesOfInterest);
					ArrayList<Double> point = (ArrayList<Double>) sv.getValue(model.getFirstInitialState());

					w_v_checked_rs.add(weights);
					w_v_checked_rs.add(point);
					paretoCurve.add(point);
					mainLog.println(w1 + ":" + w2 + " = " + point);
				}
				mainLog.println("\nPareto curve: " + paretoCurve);
			}
		}
	 	
		mainLog.println("*********************ParetoCurve by iterating [w1 w2] Random Sampling*******************************");
		
		mainLog.println("\nPareto curve: " +paretoCurve.size()+"\n"+ paretoCurve);
		ArrayList<ArrayList<Double>> paretoCurveCompact = new ArrayList<ArrayList<Double>>();
		for (int iprint=0; iprint<paretoCurve.size(); iprint++){
			if (!containsWithError(paretoCurveCompact, (ArrayList<Double>) paretoCurve.toArray()[iprint],1E-06)){
				paretoCurveCompact.add((ArrayList<Double>)paretoCurve.toArray()[iprint]);
			}
		}
		mainLog.println("\nPareto curve (compact)" + paretoCurveCompact.size());

		for (int iprint=0; iprint<paretoCurve.size(); iprint++){
				mainLog.println(paretoCurve.toArray()[iprint]);
		}


		HashSet values_rs = new HashSet();
		mainLog.println("Weights and vectors checked by random sampling start: ");
		for (int iprint=0; iprint<w_v_checked_rs.size()/2;iprint++){
			mainLog.print("weight: "+Arrays.toString(w_v_checked_rs.get(iprint*2).toArray())+"; vector: "+Arrays.toString(w_v_checked_rs.get(iprint*2+1).toArray())+"\n");
			values_rs.add(innerProduct(w_v_checked_rs.get(iprint*2),w_v_checked_rs.get(iprint*2+1)));
		}
		mainLog.println("Weights and vectors checked by random sampling end: ");
		//mainLog.println("scalarized values RS:"+values_rs.size());
		//mainLog.println(values_rs);
		
		// Return Pareto curve as Point list
		List<Point> points = new ArrayList<>();
		for (ArrayList<Double> paretoPoint : paretoCurveCompact) {
			Point point = new Point(paretoPoint.size());
			for (int dim = 0; dim < paretoPoint.size(); dim++) {
				point.setCoord(dim, paretoPoint.get(dim));
			}
			points.add(point);
		}
		Object array[] = new Object[model.getNumStates()];
		array[model.getFirstInitialState()] = points;
		return StateValues.createFromObjectArray(TypeDouble.getInstance(), array, model);
    }
    
    protected StateValues checkExpressionParetoMultiObjPOMDP(POMDP pomdp, List<MDPRewards> mdpRewardsList, BitSet target, List<MinMax> minMaxList, BitSet statesOfInterest) throws PrismException
    {
    	mainLog.println("Random sampling***********");
    	checkExpressionParetoMultiObjMDPWithRandomSampling( pomdp,  mdpRewardsList, target, minMaxList, statesOfInterest);
    	mainLog.println("Random sampling***********");
		long startTime = System.currentTimeMillis();

    	int numObjs = minMaxList.size();
		int nStates = pomdp.getNumStates();
		int numUnobs = pomdp.getNumUnobservations();
		
		
		BitSet targetObs = ((POMDPModelChecker) mc).getObservationsMatchingStates(pomdp, target);
		// Check we are only computing for a single state (and use initial state if unspecified)
		if (statesOfInterest == null) {
			statesOfInterest = new BitSet();
			statesOfInterest.set(pomdp.getFirstInitialState());
		} else if (statesOfInterest.cardinality() > 1) {
			throw new PrismNotSupportedException("POMDPs can only be solved from a single start state");
		}	
		
		if (targetObs == null) {
			throw new PrismException("Target for expected reachability is not observable");
		}
		// Find _some_ of the states with infinite reward
		// (those from which *every* MDP strategy has prob<1 of reaching the target,
		// and therefore so does every POMDP strategy)
		MDPModelChecker mcProb1 = new MDPModelChecker(this);
		BitSet inf = mcProb1.prob1(pomdp, null, target, false, null);
		inf.flip(0, pomdp.getNumStates());
		// Find observations for which all states are known to have inf reward
		BitSet infObs = ((POMDPModelChecker) mc).getObservationsCoveredByStates(pomdp, inf);
		//mainLog.println("target obs=" + targetObs.cardinality() + ", inf obs=" + infObs.cardinality());
		
		// Determine set of observations actually need to perform computation for
		// eg. if obs=1 & unknownObs(obs)=true -> obs=1 needs computation
		// eg. if obs=2 & unknownObs(obs)=false -> obs=1 does not need computation
		BitSet unknownObs = new BitSet();
		unknownObs.set(0, pomdp.getNumObservations());
		unknownObs.andNot(targetObs);
		unknownObs.andNot(infObs);
		ArrayList<Integer> endStates = new ArrayList<Integer>();
		for (int i=0; i<nStates;i++) {
			if (!unknownObs.get(pomdp.getObservation(i))) {
				mainLog.println("end state="+i+"Obs="+pomdp.getObservation(i));
				endStates.add(i);
			}
		}
		
		int endState = -1;
		for (int i=0; i<nStates;i++) {
			if (!unknownObs.get(pomdp.getObservation(i))) {
				endState=i;
				break;
			}
		}
		
		ArrayList<Object> allActions = ((POMDPModelChecker) mc).getAllActions(pomdp);
		int nActions = allActions.size();
		
		int numRewards = mdpRewardsList.size();
		
    	HashSet<List<Double>> paretoCurve = new HashSet<>();
		ArrayList<ArrayList<Double>> partial_CCS = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> partial_CCS_weights = new ArrayList<ArrayList<Double>>();

		//Line 2
		ArrayList<ArrayList<Double>> w_v_checked = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> vector_checked = new ArrayList<ArrayList<Double>>();
		ArrayList<ArrayList<Double>> weights_checked = new ArrayList<ArrayList<Double>>();
		
		HashMap <ArrayList<Double>, ArrayList<ArrayList<Double> >> corner_to_value = new HashMap < ArrayList<Double>, ArrayList<ArrayList<Double>>> ();
		HashMap <ArrayList<Double>, ArrayList<ArrayList<Double> >> value_to_corner = new HashMap < ArrayList<Double>, ArrayList<ArrayList<Double>>> ();
		
		//Line 3 
		ArrayList<ArrayList<Double>> priority_queue = new ArrayList<ArrayList<Double>>();
		//Line 4
		priority_queue= initialQueue(minMaxList, corner_to_value, pomdp);
		
		//line 5
		ArrayList<AlphaMatrix> A_all = new ArrayList<AlphaMatrix> ();
		ArrayList<AlphaMatrix> immediateRewards = new ArrayList<AlphaMatrix>();
		ArrayList<AlphaMatrix> V= new ArrayList<AlphaMatrix>();
		
		//immediate reward vector
		ArrayList<Double> Rmin = new ArrayList<Double>();
		for(int obj=0; obj<numRewards; obj++) {
			Rmin.add(Double.POSITIVE_INFINITY);
		}
		for (int a=0; a<nActions; a++) {
			Object action = allActions.get(a);
			for (int s=0; s<nStates; s++) {
				for(int obj=0; obj<numRewards; obj++) {
					if (pomdp.getAvailableActions(s).contains(action)) {
						int choice = pomdp.getChoiceByAction(s, action);
						double immediateReward =  mdpRewardsList.get(obj).getTransitionReward(s,choice) + mdpRewardsList.get(obj).getStateReward(s);
						immediateReward *= minMaxList.get(obj).isMin() ? -1 :1;
						if (immediateReward < Rmin.get(obj)) {
							Rmin.set(obj, immediateReward);
						}
					}
				}
			}
		}

		for (int a =0; a<nActions; a++) {
			double [][]matrix = new double [nStates][numRewards];
			Object action = allActions.get(a);
			for (int s=0; s<nStates; s++) {
				for (int obj=0; obj<numRewards; obj++) {
					if (pomdp.getAvailableActions(s).contains(action)) {
						int choice = pomdp.getChoiceByAction(s, action);
						double immediateReward =  mdpRewardsList.get(obj).getTransitionReward(s,choice) + mdpRewardsList.get(obj).getStateReward(s);
						immediateReward *= minMaxList.get(obj).isMin() ? -1 :1;
						matrix [s][obj] =  immediateReward;
					}
					else {
						matrix [s][obj] = Rmin.get(obj)*10;
					}
					if (endStates.contains(s)) {
						matrix [s][obj] = 0 ;
					}
				}
			}
			AlphaMatrix am = new AlphaMatrix(matrix);
			am.setAction(a);
			immediateRewards.add(am);
			//V.add(am);
			//A_all.add(am);
		}
		
		// initial vector 
		double [][]matrixInit = new double [nStates][numRewards];
		for (int s=0; s<nStates; s++) {
			for (int obj=0; obj<numRewards; obj++) {
				matrixInit [s][obj] = Rmin.get(obj)*10*100;
			}
		}
		AlphaMatrix amInit  = new AlphaMatrix(matrixInit);
		amInit .setAction(0);
		V.add(amInit );
		A_all.add(amInit);
		
		
		immediateRewards =((POMDPModelChecker) mc).copyAlphaMatrixSet(immediateRewards);
		A_all =((POMDPModelChecker) mc).copyAlphaMatrixSet(A_all);
		/*for (int a=0; a<allActions.size();a++) { 
			double [][] matrix = new double [nStates][numObjs];
			double Rmin =0.1;
			for (int i=0; i<nStates; i++) {
				for (int j=0; j<numObjs; j++) {
					matrix[i][j] = Rmin;
				}
			}
			AlphaMatrix am = new AlphaMatrix(matrix); //alphaMatrix
			am.setAction(a);
			A_all.add(am);
		}
		*/
		//check
		mainLog.println("immediate reward");
		for (int i=0; i<immediateRewards.size(); i++){
			AlphaMatrix am= immediateRewards.get(i);
			mainLog.println(allActions.get(am.getAction()));
			mainLog.println(am);
		}
		
		mainLog.println("initial vector");
		for (int i=0; i<A_all.size(); i++){
			AlphaMatrix am= A_all.get(i);
			mainLog.println(am);
		}
		
		ArrayList<Belief> belief_set = ((POMDPModelChecker) mc).randomExploreBeliefs(pomdp, target, statesOfInterest);
		mainLog.println("Belie set size= "+belief_set.size());
		while(priority_queue.size()>0){

			mainLog.println("Current Q (weight, priority) Before Pop"+Arrays.toString(priority_queue.toArray()));
			ArrayList<Double> w_pop = deQueue(priority_queue);
			double[] w_pop_array = new double [w_pop.size()];
			for (int w=0; w<w_pop.size(); w++) {
				w_pop_array[w] = (double) w_pop.get(w);
			}
			mainLog.println("Current weight "+Arrays.toString(w_pop_array));
			
			mainLog.println("Current Q (weight, priority) After Pop"+Arrays.toString(priority_queue.toArray()));
			
			//Line 9  Select the best A from A_all for each b \belong belief, give w
			ArrayList<AlphaMatrix> Ar =  new ArrayList<AlphaMatrix> ();
			for (int i=0; i<belief_set.size();i++){
				Belief belief_candidate =  belief_set.get(i);
				int maxValueIndex = AlphaMatrix.getMaxValueIndex(belief_candidate, A_all, w_pop_array, pomdp);
				AlphaMatrix A_candidate = A_all.get(maxValueIndex);
				if(!Ar.contains(A_candidate)) {
				Ar.add(A_candidate);
				}
			}
			mainLog.println("Ar size= "+Ar.size());

	    	double threshold = 0.00001; // threshold of allowable error to determine if two weights are the same
	    	
			//line 10 
			double eta = 1E-5;

			ArrayList<AlphaMatrix> Aw = ((POMDPModelChecker) mc).solveScalarizedPOMDP(Ar, belief_set, w_pop_array, eta, pomdp, immediateRewards, V, endState,startTime);

			//Line 11
			Belief b0=pomdp.getInitialBelief();
			int bestAlphaMatrixIndex = AlphaMatrix.getMaxValueIndex(b0, Aw, w_pop_array, pomdp);
			AlphaMatrix bestAlphaMatrix = Aw.get(bestAlphaMatrixIndex);
			mainLog.println("Best matrix="+bestAlphaMatrix);
			double [][] matrix = bestAlphaMatrix.getMatrix();
			double [] belief0 = b0.toDistributionOverStates(pomdp);
			ArrayList<Double> Vb0 = new ArrayList<Double> ();
			for (int j=0; j<numObjs; j++) {
				double value = 0;
				for (int i=0; i<belief0.length; i++) {
					value += belief0[i] * matrix[i][j];
				}
				Vb0.add(value);
				mainLog.println("value"+value);
			}
			
			//Line 12 update A_all
			for (int i=0; i<Aw.size(); i++) {
				A_all.add(Aw.get(i));
			}
			int countNewWeights = 0; //number of weights generated by u

			//Line 13 TO CHecker
			ArrayList<Double> u = new ArrayList<Double> ();
			for (int i=0; i<Vb0.size(); i++) {
				u.add(Math.abs(Vb0.get(i)));
			}
			mainLog.println("u="+u);
			w_v_checked.add((ArrayList<Double>) w_pop.clone());
			weights_checked.add((ArrayList<Double>) w_pop.clone());
			w_v_checked.add((ArrayList<Double>) u.clone());
			vector_checked.add((ArrayList<Double>) u.clone());
			
			/////////////////////////////////////////////////////////////////////////////////////////////////////////
			if (!containsWithError(partial_CCS,u, 1E-5)) {
				if (partial_CCS.size()==0) {// when to compute
					for (int i_queue=0; i_queue<priority_queue.size();i_queue++){
						ArrayList<Double> weight_tp = (ArrayList<Double>) priority_queue.get(i_queue).clone();
						weight_tp.remove(weight_tp.size()-1);
						ArrayList<ArrayList<Double>> current_value_set = (ArrayList<ArrayList<Double>>) corner_to_value.get(weight_tp).clone();
						current_value_set.add(u);
						corner_to_value.put(weight_tp, current_value_set );

						ArrayList<ArrayList<Double>> weight_tp_set =  new ArrayList<ArrayList<Double>> ();
						if(value_to_corner.containsKey(u))
							weight_tp_set = (ArrayList<ArrayList<Double>>) value_to_corner.get(u).clone();
						weight_tp_set.add(weight_tp);
						value_to_corner.put(u,weight_tp_set);
					}
					mainLog.println("add value vector from 1st exterme weights");
					partial_CCS.add((ArrayList<Double>) u.clone());
					partial_CCS_weights.add((ArrayList<Double>) w_pop.clone());
					mainLog.println(partial_CCS.size());
				}
				else {
					mainLog.println("elsess");
					double original_value = innerProduct(adjustWeight(w_pop,minMaxList, pomdp), u);
					double other_prod = innerProduct(adjustWeight(w_pop,minMaxList,pomdp), corner_to_value.get(w_pop).get(corner_to_value.get(w_pop).size()-1));
					if ((original_value - other_prod)>1E-08){

						//remove from value dict
						ArrayList<ArrayList<Double>> existing_value_vectors = corner_to_value.get(w_pop);
						ArrayList<ArrayList<Double>> existing_weights = new ArrayList<ArrayList<Double>> () ;
						for (int i_evv=0; i_evv<existing_value_vectors.size(); i_evv++){
							ArrayList<Double> existing_value_vector = existing_value_vectors.get(i_evv);
							if (value_to_corner.containsKey(existing_value_vector)){
								existing_weights = value_to_corner.get(existing_value_vector);
								for (int j_ew=0; j_ew<existing_weights.size();j_ew++){
									ArrayList<Double> existing_weigth = existing_weights.get(j_ew);
									if ( containsWithError(existing_weights, w_pop, threshold) && (!(w_pop.contains(1.0)))){
										int tp_index = existing_weights.indexOf(w_pop);
										value_to_corner.get(existing_value_vector).remove(tp_index);
									}
								}
							}
						}

						//check obsolete 
						ArrayList<ArrayList<Double>> weight_list = new ArrayList<ArrayList<Double>> ();
						weight_list.add(w_pop);
						ArrayList<ArrayList<Double>> obsolete_list = new ArrayList<ArrayList<Double>> ();
						while (weight_list.size()>0){
							ArrayList<Double> weight = weight_list.get(weight_list.size()-1);
							weight_list.remove(weight_list.size()-1);
							if (corner_to_value.containsKey(weight)){
								existing_value_vectors = (ArrayList<ArrayList<Double>>) corner_to_value.get(weight).clone();
								ArrayList<Double> existing_value_vector = existing_value_vectors.get(existing_value_vectors.size()-1);
								double scalarized_value = innerProduct(existing_value_vector, adjustWeight(weight,minMaxList,pomdp));
								if (original_value>scalarized_value){
									for (int i_evv=0; i_evv<existing_value_vectors.size(); i_evv++){
										existing_value_vector = existing_value_vectors.get(i_evv);
										if (value_to_corner.containsKey(existing_value_vector)){
											mainLog.println("+++++++++corner_to_value");
											for (Object  key:corner_to_value.keySet()){
												ArrayList<ArrayList<Double>> tp = (ArrayList<ArrayList<Double>>) corner_to_value.get(key);
												for (int i=0; i< tp.size(); i++){
													mainLog.println(key+" -> "+ Arrays.toString(((ArrayList<Double>) tp.get(i) ).toArray()));
												}
											}
											mainLog.println("+++++++++value_to_corner");
											for (Object  key:value_to_corner.keySet()){
												ArrayList<ArrayList<Double>> tp = (ArrayList<ArrayList<Double>>) value_to_corner.get(key);
												for (int i=0; i< tp.size(); i++){
													mainLog.println(key+" -> "+ Arrays.toString(((ArrayList<Double>) tp.get(i) ).toArray()));
												}
											}
											ArrayList<ArrayList<Double>> current_weights = value_to_corner.get(existing_value_vector);
											for (int j_cw=0; j_cw<current_weights.size(); j_cw++){
												ArrayList<Double> current_weight = current_weights.get(j_cw);
												if ((!current_weights.equals(weight)) && (obsolete_list.contains(current_weight))){
													weight_list.add((ArrayList<Double>) current_weight.clone());
												}
											}											
										}
									}
									obsolete_list.add((ArrayList<Double>) weight.clone());
								}
							}
						}

						for (int iprint=0; iprint<obsolete_list.size();iprint++){
							mainLog.println("obsolete_list: "+Arrays.toString(obsolete_list.get(iprint).toArray())+"\n");
						}

						///compute new corner
						ArrayList<ArrayList<Double>> boundaries=new ArrayList<ArrayList<Double>>();
						for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
							ArrayList<Double> obsolete_weight = obsolete_list.get(i_obs);
							for (int j_obs=0; j_obs<obsolete_weight.size();j_obs++){
								ArrayList<Double> boundary = new ArrayList<Double> ();
								boundary.add((double) j_obs);
								if (((double) obsolete_weight.get(j_obs)==0) && (!boundaries.contains(boundary)))
									boundaries.add(boundary);
							}
						}

						ArrayList<ArrayList<Double>> old_value_vectors = new ArrayList<ArrayList<Double>>  ();

						for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
							ArrayList<Double> found_weight = obsolete_list.get(i_obs);
							ArrayList<ArrayList<Double>> found_values = corner_to_value.get(found_weight);
							for (int j_fv=0; j_fv<found_values.size(); j_fv++){
								ArrayList<Double> found_value = found_values.get(j_fv);
								mainLog.println("found_value"+Arrays.toString(found_value.toArray()));
								mainLog.println(!old_value_vectors.contains(found_value));
								mainLog.println("u"+Arrays.toString(u.toArray()));
								mainLog.println(!found_value.equals(u));
								if((!old_value_vectors.contains(found_value))&&(!found_value.equals(u))) {
									old_value_vectors.add((ArrayList<Double>) found_value.clone());
								}
							}
						}
						// /*
						old_value_vectors = new ArrayList<ArrayList<Double>>  ();

						for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
							double bestValue = innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, pomdp), partial_CCS.get(0));
							for (int j_partialCSS=0; j_partialCSS < partial_CCS.size(); j_partialCSS++){
								if (innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, pomdp), partial_CCS.get(j_partialCSS))>bestValue){
									bestValue = innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, pomdp), partial_CCS.get(j_partialCSS));
								}
							}
							for (int j_partialCSS=0; j_partialCSS < partial_CCS.size(); j_partialCSS++){
								if (Math.abs(innerProduct(adjustWeight((ArrayList<Double>) obsolete_list.get(i_obs), minMaxList, pomdp), partial_CCS.get(j_partialCSS))-bestValue)<1E-06){
									if (old_value_vectors.size()<numObjs){ //if Vs(w) contians fewer than dvalue vecotrs
										old_value_vectors.add((ArrayList<Double>) partial_CCS.get(j_partialCSS).clone());
									}
								}
							}
						}

						for (int i_b=0; i_b<boundaries.size();i_b++){
							old_value_vectors.add((ArrayList<Double>) boundaries.get(i_b).clone());
						}

						for (int iprint=0; iprint<old_value_vectors.size();iprint++){
							mainLog.println("old_value_vectors: "+Arrays.toString(old_value_vectors.get(iprint).toArray())+"\n");
						}

						//compute new points
						//Add to queue
						ArrayList<ArrayList<Double>> subset = new ArrayList<ArrayList<Double>>(); //one kind of combination

						ArrayList<Double> tpp= new ArrayList<Double>();
						tpp.add(1.0);
						tpp.add(1.0);
						for (int i_ojs=0; i_ojs<numObjs-1;i_ojs++){
							subset.add(tpp);
						}

						ArrayList<ArrayList<ArrayList<Double>>> subsets = new ArrayList<ArrayList<ArrayList<Double>>>(); //all combination
						mainLog.println("old_value_vectors size"+old_value_vectors.size());
						combinations2(old_value_vectors, numObjs-1, 0, subset, subsets);
						mainLog.println("allsubsets: total number of combinations"+Arrays.toString(subsets.toArray())+subsets.size());
						
						for(int i_subset=0; i_subset<subsets.size();i_subset++){
							ArrayList<ArrayList<Double>> hCCS = new ArrayList<ArrayList<Double>>(); //optimistic hypothetical CCS
							ArrayList<ArrayList<Double>> A = new ArrayList<ArrayList<Double>>();
							ArrayList<Double> augumented_vector = new ArrayList<Double>();
							ArrayList<Double> bound_from_w_obsolete = new ArrayList<Double>();
							ArrayList<ArrayList<Double>> oneCombination =(ArrayList<ArrayList<Double>> ) subsets.get(i_subset).clone();
							for (int j=0; j<oneCombination.size(); j++){
								augumented_vector = (ArrayList<Double>) oneCombination.get(j).clone();
								if (augumented_vector.size()==numObjs){
									hCCS.add((ArrayList<Double>) augumented_vector.clone());
									augumented_vector.add(-1.0);
									A.add(augumented_vector);
								}
								else{
									bound_from_w_obsolete.add((double) augumented_vector.get(0));
								}
							}
							hCCS.add((ArrayList<Double>) u.clone());
							augumented_vector = (ArrayList<Double>) u.clone();
							augumented_vector.add(-1.0);
							A.add((ArrayList<Double>) augumented_vector.clone());

							//simplex constraint
							ArrayList<Double> bound = new ArrayList<Double>();
							for (int i=0; i<numObjs;i++) {
								bound.add(1.0);
							}
							bound.add(0.0);
							A.add(bound);


							// remove column that has bound. (E.g. for weight [0.5,0.5,0], the boundary index is 2, then remove column 2 from A)
							
							for (int i_bf=0; i_bf<bound_from_w_obsolete.size();i_bf++){
								double removeIndex = (double) bound_from_w_obsolete.get(i_bf);
								int remove = (int) removeIndex;
								for (int i_A=0; i_A<A.size(); i_A++){
									A.get(i_A).remove(remove);
								}
							}
							
							ArrayList<Double> b = new ArrayList<Double>();
							for (int i=0; i<A.size()-1; i++) {
								b.add(0.0);
							}
							b.add(1.0);

							ArrayList<Double> w_new = new ArrayList<Double>();
							w_new = linSolver(A,b);
							w_new.remove(w_new.size()-1);

							for (int i_bf=0; i_bf<bound_from_w_obsolete.size();i_bf++){
								double insertIndex = (double) bound_from_w_obsolete.get(i_bf);
								int insert = (int) insertIndex;
								w_new.add(insert,0.0);
							}

							Boolean allPositive = true;
							for (int iw=0; iw<w_new.size();iw++){
								if ((double) w_new.get(iw)<0){
									allPositive = false;
								}
							}
							if (!allPositive){
								mainLog.println("Negative... continue");
								continue;
							}
							if (w_new.contains(1.0)){
								mainLog.println("Extreme... continue");
								continue;
							}
							if (w_new.contains(Double.NaN)){
								mainLog.println("NaN... continue");
								continue;
							}
							mainLog.println("generateing new weights by"+Arrays.toString(u.toArray()));
							
							countNewWeights++;
							mainLog.println(countNewWeights+"Number of New weights generated by :"+Arrays.toString(u.toArray()));
							mainLog.println("w_new"+Arrays.toString(w_new.toArray()));
							if (countNewWeights>numObjs)
								mainLog.println("More new weights than expected");

							//////// this is for rounding
							double weigth_sum = 0.0;
							for (int iw=0;iw<w_new.size()-1;iw++){
								w_new.set(iw, (double) Math.round((double)w_new.get(iw) * 1000000)/1000000);
								weigth_sum += (double) w_new.get(iw);
							}
							w_new.set(w_new.size()-1, (double) 1-weigth_sum);
							mainLog.println("w_new (sum to 1)"+Arrays.toString(w_new.toArray()));
							

							//update value_to_corner & corner_to_value
							ArrayList<ArrayList<Double>> default_value_vecotrs = new  ArrayList<ArrayList<Double>>();
							default_value_vecotrs.add((ArrayList<Double>) u.clone());
							corner_to_value.put((ArrayList<Double>) w_new.clone(), default_value_vecotrs);

							ArrayList<ArrayList<Double>> new_weights = new  ArrayList<ArrayList<Double>>();
							new_weights.add((ArrayList<Double>) w_new.clone());
							value_to_corner.put(u,new_weights);

							// Add to priority queue
							double priority=1.0;

							double VCCS = maxValueLP(minMaxList, pomdp, w_new, partial_CCS , partial_CCS_weights, u, w_pop );
							double Vsw = innerProduct(u, adjustWeight(w_new, minMaxList, pomdp));
							priority = Math.abs((VCCS-Vsw)/(VCCS));
							mainLog.println("computing priority = "+priority);

							if (priority > threshold){
								w_new.add(priority);
								priority_queue.add((ArrayList<Double>) w_new.clone());
							}

							//delete obsolete list from priority queue
							for (int i_obs=0; i_obs<obsolete_list.size();i_obs++){
								ArrayList<Double> obsolete_weight =  obsolete_list.get(i_obs);
								if (!obsolete_weight.contains(1.0)){
									for (int j_queue=0; j_queue<priority_queue.size(); j_queue++){
										ArrayList<Double> tp_weight = (ArrayList<Double>) priority_queue.get(j_queue).clone();
										tp_weight.remove(tp_weight.size()-1);
										if (tp_weight.equals(obsolete_weight)){
											mainLog.println("Removing obsolete_weight:"+ Arrays.toString(obsolete_weight.toArray()));
											priority_queue.remove(j_queue);
										}

									}
								}
							}

						}
					}
				//
				//add to solution
				partial_CCS.add((ArrayList<Double>) u.clone());
				partial_CCS_weights.add((ArrayList<Double>) w_pop.clone());
				}
			}
			else {
				mainLog.println("Vector already in the partial CCS");
			}
		}
		double elapsed = (System.currentTimeMillis() - startTime) * 0.001;
		mainLog.println("total time elapsed = " + elapsed);
		mainLog.println("ALl weights checked:"+ weights_checked.size());
		HashSet values_OLS = new HashSet();

		for (int iprint=0; iprint<weights_checked.size();iprint++){
			mainLog.print("weight: "+Arrays.toString(weights_checked.get(iprint).toArray())+"; vector: "+Arrays.toString(vector_checked.get(iprint).toArray())+"\n");
		}
		mainLog.println("*********************ParetoCurve by optimal linear solution*******************************");

		for (int iprint=0; iprint<partial_CCS.size();iprint++){
			mainLog.print("weight: "+Arrays.toString(partial_CCS_weights.get(iprint).toArray())+"; vector: "+Arrays.toString(partial_CCS.get(iprint).toArray())+"\n");
			values_OLS.add(innerProduct(partial_CCS_weights.get(iprint),partial_CCS.get(iprint)));

		}
		mainLog.print("#weights: "+partial_CCS_weights.size()+"\n");
		for (int iprint=0; iprint<partial_CCS.size();iprint++){
			mainLog.print(Arrays.toString(partial_CCS_weights.get(iprint).toArray())+"\n");
		}
		mainLog.println("#Parecto Curve points: "+partial_CCS.size()+"\n");
		for (int iprint=0; iprint<partial_CCS.size();iprint++){
			mainLog.print(Arrays.toString(partial_CCS.get(iprint).toArray())+"\n");
		}
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////
    	// Dummy return value
		return StateValues.createFromSingleValue(TypeDouble.getInstance(), 0.0, pomdp);
    }
    
	public ArrayList<Double> linSolver(ArrayList<ArrayList<Double>> A, ArrayList<Double> b)
	{
		if (A.get(0).size()!=A.size()){
			mainLog.println("Matrix is not square!");
		}
		ArrayList<ArrayList<Double>> Ab = new ArrayList<ArrayList<Double>>();
		for (int i=0; i<A.size(); i++) {
			Ab.add( (ArrayList<Double>) A.get(i).clone() );
			Ab.get(i).add(b.get(i));
		}
		mainLog.println("\nA:"+Arrays.toString(A.toArray()));
		mainLog.println("\nb:"+Arrays.toString(b.toArray()));		
		for (int k=0; k<Ab.size()-1; k++) {
			mainLog.println("Ab0:"+Arrays.toString(Ab.toArray()));

			double pivot = Ab.get(k).get(k);
			mainLog.println("k:"+k);
			// find the max and swap
			double max=pivot;
			int max_location=k;
			for (int imax=k;imax<Ab.size();imax++) {
				if (Ab.get(imax).get(k)>max) {
					max = Ab.get(imax).get(k);
					max_location=imax;
			//		mainLog.println("max:"+max);
			//		mainLog.println("max_location:"+max_location);

				}
			}
			//mainLog.println("max_location:"+max_location);
			ArrayList<Double> tpmax= (ArrayList<Double>) Ab.get(k).clone();
			Ab.set(k, (ArrayList<Double>) Ab.get(max_location).clone());
			Ab.set(max_location, tpmax);
			pivot=Ab.get(k).get(k);
			if (pivot==0) {
				continue;
			}
			mainLog.println("Ab2:"+Arrays.toString(Ab.toArray()));

			/*
			if (pivot==0){
				//swap
				ArrayList<Double> tp= (ArrayList<Double>) Ab.get(k).clone();
				Ab.set(k, (ArrayList<Double>) Ab.get(k+1).clone());
				Ab.set(k+1, tp);
				pivot=Ab.get(k).get(k);
				mainLog.println("swap pivot:"+pivot);
			}
			*/
			//mainLog.println("start reverse pivot:"+pivot);
			for (int j=k; j<Ab.get(0).size(); j++) {
				Ab.get(k).set(j, Ab.get(k).get(j)/pivot);
			}
			mainLog.println("Ab3:"+Arrays.toString(Ab.toArray()));

			for (int i= k+1; i<Ab.size(); i++) {
				pivot = Ab.get(i).get(k);
				for (int j=0; j<Ab.get(0).size(); j++) {
					Ab.get(i).set(j, Ab.get(i).get(j)-Ab.get(k).get(j)*pivot);
				}
			}
			//mainLog.println("Ab4:"+Arrays.toString(Ab.toArray()));

		}
		for (int k=Ab.size()-1; k>0;k--) {
			double pivot = Ab.get(k).get(k);
			//mainLog.println("pivot:"+pivot);

			if (pivot==0){
				continue;
			}
			//mainLog.println("pivot:"+pivot);

			for (int j=0; j<Ab.get(0).size();j++) {
				Ab.get(k).set(j, Ab.get(k).get(j)/pivot);
			}
			for (int i=k-1; i>=0; i--) {
				pivot=Ab.get(i).get(k);
				for (int j=0; j<Ab.get(0).size();j++) {
					Ab.get(i).set(j, Ab.get(i).get(j)-Ab.get(k).get(j)*pivot);
				}
			}
		}

		ArrayList w_new = new ArrayList<Double>();
		for (int i=0; i<Ab.size(); i++) {
			w_new.add(Ab.get(i).get(Ab.get(i).size()-1));
		}
		mainLog.println("solved Ab:"+Arrays.toString(Ab.toArray()));
		return w_new;
		/* Jacobi
		ArrayList<Double> x = new ArrayList<Double>();
		ArrayList<Double> x_old = new ArrayList<Double>();
		for (int i=0; i<numObjs; i++) {
			x.add(1.0);
			x_old.add(1.5);
		}
		x.add(1.0);				
		x_old.add(1.0);
		int max_iteration = 999;
		for (int iteration=0; iteration<max_iteration; iteration++ ) {
			for (int i=0;i<x.size();i++) {
				x_old.set(i, x.get(i));
			}
			for (int i_objective=0; i_objective<numObjs+1; i_objective++) {
				double tp = 0;
				mainLog.println("----");
				for (int j_objective=0; j_objective<numObjs+1; j_objective++) {
					if (i_objective!=j_objective) {
						//tp += a_ij * xk_j;
						tp += A.get(i_objective).get(j_objective)* x_old.get(j_objective);
						mainLog.println("Aij:"+A.get(i_objective).get(j_objective));
						mainLog.println("xj:"+x_old.get(j_objective));
					}
				}
				x.set(i_objective, (b.get(i_objective)-tp)/(A.get(i_objective).get(i_objective)));
			}
		}
		*/
	}
	public boolean containsWithError(ArrayList<ArrayList<Double>> S, ArrayList<Double> u, double error_threshold){
		for (int i=0; i<S.size(); i++){
			double error =0.0;
			for (int j=0; j<u.size(); j++){
				error += Math.abs(S.get(i).get(j)-u.get(j));
			}
			if (error<error_threshold){
				return true;
			}
		}
		return false;
	}

//	combinations2(old_value_vectors, numObjs-1, 0, subset, subsets);


    public void combinations2(ArrayList<ArrayList<Double>> arr, int len, int startPosition, ArrayList<ArrayList<Double>> result,  ArrayList<ArrayList<ArrayList<Double>>> subsets ){
        if (len == 0){
        	mainLog.println("one instace of combinations");
		    mainLog.println(Arrays.toString(result.toArray()));
            subsets.add((ArrayList<ArrayList<Double>> )result.clone());
            return;
        } 

        for (int i = startPosition; i <= arr.size()-len; i++){
            //result[result.length - len] = arr[i];
            result.set(result.size()-len, (ArrayList<Double>) arr.get(i));
            //result.add((ArrayList<Double>) arr.get(i));
            combinations2(arr, len-1, i+1, result, subsets);
            
        }
    }       

    public double innerProduct(ArrayList<Double> A, ArrayList<Double> B){
    	//compute innerproduct of vector A, B
    	double result=0.0;
    	if(A.size()!=B.size()){
    		mainLog.println("vectors should have same size");
    	}
    	else{
    		for (int i=0; i<A.size();i++){
    			result += ((double) A.get(i) )* ((double) B.get(i));
    		}
    	}
    	return result;
    }
    public double innerProduct(double [] A, ArrayList<Double> B){
    	//compute innerproduct of vector A, B
    	double result=0.0;
    	if(A.length!=B.size()){
    		mainLog.println("vectors should have same size");
    	}
    	else{
    		for (int i=0; i<B.size();i++){
    			result += (A[i] )* ((double) B.get(i));
    		}
    	}
    	return result;
    }

    public ArrayList<Double> adjustWeight(ArrayList<Double> weights, List<MinMax> minMaxList, Model model)throws PrismException
    {
    	// this function is to convert weigths for 'min' to 'max'
    	ArrayList<Double> weights_adjust_min_max = new ArrayList<Double>();

	    for (int i_weight=0;i_weight<minMaxList.size();i_weight++){
			if (minMaxList.get(i_weight).isMin()){
				weights_adjust_min_max.add(-1.0*((double) weights.get(i_weight)));
			}
			else{
				weights_adjust_min_max.add(((double) weights.get(i_weight)));
			}
	    }
	    return weights_adjust_min_max;
    }
    
    /* compute the max improvement 
     * See "Linear Support for Multi-Objective Coordination Graphs"
     * @param objs, list of reward expression, used to adapt min/max
     * @param model, model, used to adapt min/max
     * @param w_new, the newly generated weight, for which this function is computing the priority
     * @param partial_CCS, list of payoff vectors
     * @param partial_CCS, list of weights corresponding to the payoff vectors
     * @param u, the newly computed payoff vector (see Line 8 Algorithm 1 )
     * @param w_pop, the newly popped weight (see Line 7 Algorithm 1) 
     * */
    public double  maxValueLP(List<MinMax> minMaxList, Model model, ArrayList<Double> w_new, ArrayList<ArrayList<Double>> partial_CCS , ArrayList<ArrayList<Double>> partial_CCS_weights, ArrayList<Double> u, ArrayList<Double> w_pop ) throws PrismException 
    {
    	double value = 1;
    	try {
    		lpsolve.LpSolve solver = lpsolve.LpSolve.makeLp(0, w_new.size());
        	double[] objFun = adjustWeight( w_new,minMaxList, model).stream().mapToDouble(Double::doubleValue).toArray();
        	solver.strSetObjFn(Arrays.toString(objFun).replace("[", "").replace("]", "").replace(",", ""));
			solver.setVerbose(lpsolve.LpSolve.CRITICAL);

    		solver.setMaxim();
    		for (int i=0; i<partial_CCS_weights.size(); i++) {
    			double [] w = adjustWeight( partial_CCS_weights.get(i),minMaxList, model).stream().mapToDouble(Double::doubleValue).toArray();
    			double v = innerProduct(adjustWeight( partial_CCS_weights.get(i),minMaxList, model), partial_CCS.get(i));
        		solver.strAddConstraint(Arrays.toString(w).replace("[", "").replace("]", "").replace(",", ""), lpsolve.LpSolve.LE , v);
    		}
    		double [] w = adjustWeight(w_pop,minMaxList, model).stream().mapToDouble(Double::doubleValue).toArray();
    		double v = innerProduct(u, adjustWeight(w_pop,minMaxList, model));
    		solver.strAddConstraint(Arrays.toString(w).replace("[", "").replace("]", "").replace(",", ""), lpsolve.LpSolve.LE , v);
            solver.solve();
            value =  solver.getObjective();
    	}
    	catch (lpsolve.LpSolveException ex) {
			PrismException ex2 = new PrismException("lpsolve threw an exception: " + ex.getMessage());
			throw ex2;
		}
    	return value;
    }
    
    public ArrayList<Double> deQueue(ArrayList<ArrayList<Double>> priority_queue ){
		ArrayList w_pop = new ArrayList<Double>();
		if (priority_queue.size()>0){
			double top_priority = -1;
			int top_priority_index =0;
			for (int i=0; i<priority_queue.size(); i++) {
				if (priority_queue.get(i).get(priority_queue.get(i).size()-1) >= top_priority) {
					top_priority = priority_queue.get(i).get(priority_queue.get(i).size()-1);
					top_priority_index = i;
				}
			}			
			w_pop = priority_queue.get(top_priority_index);
			priority_queue.remove(top_priority_index);
			w_pop.remove(w_pop.size()-1);
			/*
			//Ensure weights sum to 1
			double tp_sum=0.0;
			for (int i=0; i<w_pop.size()-1;i++){
				tp_sum += (double) w_pop.get(i);
			}
			w_pop.set(w_pop.size()-1, 1- tp_sum);
			*/
		}
		return w_pop;
    }
    public ArrayList<ArrayList<Double>> initialQueue(List<MinMax> minMaxList, HashMap corner_to_value, Model model)throws PrismException
    {
    	ArrayList<ArrayList<Double>> priority_queue = new ArrayList<ArrayList<Double>> ();
    	// create initial value vector for the exterme corner point
    	ArrayList<Double> initial_value_vector_weight = new ArrayList<Double>();
    	for (int i=0; i<minMaxList.size();i++){
			initial_value_vector_weight.add(-1.0);
    	}
    	
    	// initial value vector is adjust for "min, max"
    	// if (max max max) add (-inf, -inf, -inf)
    	initial_value_vector_weight = adjustWeight(initial_value_vector_weight, minMaxList, model);
    	ArrayList<Double> initial_value_vector = new ArrayList<Double>();
    	for (int i=0; i<minMaxList.size();i++){
			initial_value_vector.add(((double) initial_value_vector_weight.get(i)) * (Double.POSITIVE_INFINITY) );
    	}
    	ArrayList<ArrayList<Double>> initial_value_vector_sets = new ArrayList<ArrayList<Double>> ();
    	initial_value_vector_sets.add(initial_value_vector);
    	//add extreme points in the queue
		for (int i =0; i<minMaxList.size(); i++) {
			ArrayList<Double> w = new ArrayList<Double>();
			for (int j =0; j<minMaxList.size(); j++) {
				w.add(0.0);
			}
			w.set(i, 1.0); //Extremum
			corner_to_value.put((ArrayList<Double>) w.clone(), initial_value_vector_sets); // create a map from extrema to value vector
			double priority = minMaxList.get(i).isMin()? 1E6:1E5; // give min higher priority
			w.add(priority); //Add extrema with infinite priority
			
			priority_queue.add((ArrayList<Double>) w.clone());
		}

		mainLog.println("Initialize Q (weight, priority)"+Arrays.toString(priority_queue.toArray()));
		mainLog.println("initial corner_to_value");
		for (Object  key:corner_to_value.keySet()){
			ArrayList<ArrayList<Double>> tp = (ArrayList<ArrayList<Double>>) corner_to_value.get(key);
			for (int i=0; i< tp.size(); i++){
				mainLog.println(key+" -> "+ Arrays.toString(((ArrayList<Double>) tp.get(i) ).toArray()));
			}
		}
		return priority_queue;
    }

}
