pomdp

observables
started, r1taken, r1lastobs , r2taken, r2lastobs, done
endobservables
const int crashCost = 5;
const int N;

const int xMAX = 5;
const int yMAX = 5;
const int xMIN = 1;
const int yMIN = 1;
const double slippery = 0.1;
// Rock positions
const r1x = 1;
const r1y = 4;
const r2x = 1;
const r2y = 2;
// How likely is a rock a good rock
const double goodrock = 0.5;
// We are done when we reach max x location
formula finish = started & (  (x=1 & y=3) | (x=1 & y=5) | (x=2 & y=3) | (x=2 & y=4) | (x=2 & y=5)| (x=3 & y=1) | (x=3 & y=2) | (x=4 & y=1)| (x=4 & y=2)| (x=5 & y=1)| (x=5 & y=2) );
formula good = finish & done ;
observable "seefinish" = finish;
// Distance between r1 and the robot
formula r1dist = max(r1x-x,x-r1x) + max(r1y-y,y-r1y);
// max distance
formula maxdist = xMAX-xMIN+yMAX-yMIN;
// Distance between r1 and the robot
formula r2dist = max(r2x-x,x-r2x) + max(r2y-y,y-r2y);
formula bad = (r1dist=0 & !r1qual) | (r2dist=0 & !r2qual);
observable "seebad" = bad;
observable "seegood" = good;

observable "atr1" = r1dist <= 0;
observable "atr2" = r2dist <= 0;
observable "nearr1" = r1dist <= 1;
observable "nearr2" = r2dist <= 1;
formula normdistr1 = (r1dist <= 1) ? 1 : 2; //min(1+((r1dist-1)/maxdist),1.0);
formula normdistr2 = (r2dist <= 1) ? 1 : 2; //min(1+((r2dist-1)/maxdist),1.0);

module master
    started : bool init false;
    done : bool init false;

    [placement] !started -> (started'=true);
    [north] started & !done -> true;
    [south] started  & !done -> true;
    [east] started  & !done-> true;
    [west] started & !done -> true;
    [finish] finish | done -> (done'=true);
endmodule

module rock1
    r1qual : bool init false;
    r1taken : bool init false;
    r1lastobs : bool init false;
    [placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);

    [r1sample] r1dist = 0 & started & !done & !bad & !finish  & !r1taken -> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));
    [r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);
    [north] true -> (r1lastobs'=false);
    [south] true -> (r1lastobs'=false);
    [east] true -> (r1lastobs'=false);
    [west] true -> (r1lastobs'=false);
endmodule

module rock2
    r2qual : bool init false;
    r2taken : bool init false;
    r2lastobs : bool init false;
    [placement] true -> goodrock : (r2qual'=true) + (1-goodrock) : (r2qual'=false);

    [r2sample] r2dist = 0 & started & !done & !bad & !finish & !r2taken -> 1:(r2taken'=(x = r2x & y = r2y & !r2taken));
    [r2sense] started & !r2taken & !done & !bad & !finish -> (1/normdistr2): (r2lastobs'=r2qual) +  (1-(1/normdistr2)): (r2lastobs'=!r2qual);
    [north] true -> (r2lastobs'=false);
    [south] true -> (r2lastobs'=false);
    [east] true -> (r2lastobs'=false);
    [west] true -> (r2lastobs'=false);
endmodule
module robot
    x : [xMIN..xMAX] init 3;
    y : [yMIN..yMAX] init 3;

    [west] true -> (1-slippery): (x'=max(x-1,xMIN)) + slippery: (x'=max(x-2,xMIN));
    [east] true -> (1-slippery): (x'=min(x+1,xMAX)) + slippery: (x'=min(x+2,xMAX));
    [south]  true -> (1-slippery): (y'=min(y+1,yMAX)) + slippery: (y'=min(y+2,yMAX));
    [north]  true -> (1-slippery): (y'=max(y-1,yMIN)) + slippery: (y'=max(y-2,yMIN));
endmodule

rewards "cost"
    [r1sense] true : 1;
    [r1sample] !r1qual : 20;
    [r2sense] true : 1;
    [r2sample] !r2qual : 20;
    [north] true : 1;
    [south] true : 1;
    [west] true : 1;
    [east] true : 1;
    [finish] true : (!r1taken & r1qual ? 30 : 0) + (!r2taken & r2qual ? 30 : 0) ;//+ (!r3taken & r3qual ? 30 : 0) ;
    bad: crashCost;
endrewards
label "goal" = good;
label "rockposition" = (!r1taken & r1x = x & r1y = y) | (!r2taken & r2x = x & r2y = y);
label "notbad" = !bad;
