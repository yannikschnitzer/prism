{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "id": "LZocXuq41yvR"
   },
   "outputs": [],
   "source": [
    "def plot_board(obstacle, beliefState, agent, N):\n",
    "\n",
    "  from matplotlib import pyplot as plt\n",
    "  fig, ax = plt.subplots(figsize = (N,N))\n",
    "  ax.xaxis.set_ticks_position('top')   #将X坐标轴移到上面\n",
    "  ax.invert_yaxis()  \n",
    "  #\n",
    "  x = [i for i in range(N)]\n",
    "  y = [i for i in range(N)]\n",
    "  plt.xlim((0,N))\n",
    "  #plt.ylim((0,N))\n",
    "  ax.set_ylim(bottom=N, top=0)  # 此处将原点设置为左上角  \n",
    "  plt.xticks([0.5 + i for i in range(N )], labels = [str(i) for i in range(N)])\n",
    "  plt.yticks([0.5 + i for i in range(N)], labels = [str(i) for i in range(N)])\n",
    "  plt.xlabel('X Axis')\n",
    "  plt.ylabel('Y Axis')\n",
    "  width = 1\n",
    "  height =1 \n",
    "\n",
    "  for left, bottom in obstacle:\n",
    "    rect = plt.Rectangle((left, bottom), width, height, facecolor=\"red\", alpha = 1)\n",
    "    ax.add_patch(rect)\n",
    "\n",
    "  for left, bottom in beliefState:\n",
    "    rect = plt.Rectangle((left, bottom), width, height, facecolor=\"blue\", alpha = 0.5)\n",
    "    ax.add_patch(rect)\n",
    "\n",
    "  #plt.scatter(agent[0] + 0.5, agent[1] +0.5)\n",
    "  for i in range(N):\n",
    "    plt.hlines(i, 0, N , alpha = 0.5)\n",
    "    plt.vlines(i, 0, N , alpha = 0.5)\n",
    "  plt.grid(False)\n",
    "  plt.show()\n",
    "\n",
    "\n",
    "def move(belief, action):\n",
    "  result = set()\n",
    "  for x, y in belief:\n",
    "    for slip in [1, 2]:\n",
    "      if action == \"w\":\n",
    "        nx, ny = max(0, x - slip) , y\n",
    "      if action == 'e':\n",
    "        nx, ny = min(N - 1, x + slip), y\n",
    "      if action == 'n':\n",
    "        nx, ny = x, max(0, y - slip)\n",
    "      if action == 's':\n",
    "        nx, ny = x, min(N - 1, y + slip)\n",
    "      result.add((nx, ny))\n",
    "  return list(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "\n",
    "def log_print(string):\n",
    "    print(string)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "id": "-TVDCpqmffGS"
   },
   "outputs": [],
   "source": [
    "N = 2; R = 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "id": "KrKSio0_-IXo"
   },
   "outputs": [],
   "source": [
    "def generate_rocks(N, R):\n",
    "  obstacles = set()\n",
    "  import random\n",
    "  random.seed(N)\n",
    "  while len(obstacles) < R:\n",
    "    obstacle = (random.randint(0, N - 1), random.randint(0, N - 1))\n",
    "    if obstacle == (0, 0):\n",
    "      continue\n",
    "    obstacles.add(obstacle)\n",
    "  if N == 7:\n",
    "    obstacles = [(1, 1), (1, 2), (2, 1), (3, 3), (3, 5), (4, 0), (4, 1), (6, 4)]\n",
    "  \n",
    "  #log_print(\"estimated states \" + str(N * N * (3 ** R)))\n",
    "  #plot_board(obstacles, [], None, N)\n",
    "  return sorted(list(obstacles))\n",
    "obstacles = generate_rocks(N, R)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "id": "KppVWBQAS1x6"
   },
   "outputs": [],
   "source": [
    "def in_bound(obstacle, lx, ly, rx, ry):\n",
    "  x, y = obstacle[0], obstacle[1]\n",
    "  return lx <= x <= rx and ly <= y <= ry\n",
    "\n",
    "def preamble(R, obstacles, lx, ly, rx, ry):\n",
    "  log_print(\"pomdp\")\n",
    "  log_print(\"observables\")\n",
    "  observables = [\"started\"]\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    observables.append(\"r{}taken\".format(i))\n",
    "  observables.append(\"done\")\n",
    "  log_print(\", \".join(observables))\n",
    "  log_print(\"endobservables\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "3fNszRT3BQJM",
    "outputId": "078a4c47-d9df-4e68-dd67-da5b9585fc95"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "const int N;\n",
      "const int xMAX = N-1;\n",
      "const int yMAX = N-1;\n",
      "const int xMIN = 0;\n",
      "const int yMIN = 0;\n",
      "const double slippery = 0.1;\n",
      "// How likely is a rock a good rock\n",
      "const double goodrock = 0.5;\n",
      "const int primaryMinX = 0;\n",
      "const int primaryMinY = 0;\n",
      "const int primaryMaxX = 1;\n",
      "const int primaryMaxY = 1;\n",
      "const int pad = 2;\n",
      "const int areaMinX = max(primaryMinX - pad, xMIN);\n",
      "const int areaMinY = max(primaryMinY - pad, yMIN);\n",
      "const int areaMaxX = min(primaryMaxX + pad, xMAX);\n",
      "const int areaMaxY = min(primaryMaxY + pad, yMAX);\n",
      "const r1x = 0;\n",
      "const r1y = 1;\n",
      "const r2x = 1;\n",
      "const r2y = 0;\n"
     ]
    }
   ],
   "source": [
    "def grid():\n",
    "  log_print(\"const int N;\")\n",
    "  log_print(\"const int xMAX = N-1;\")\n",
    "  log_print(\"const int yMAX = N-1;\")\n",
    "  log_print(\"const int xMIN = 0;\")\n",
    "  log_print(\"const int yMIN = 0;\")\n",
    "  log_print(\"const double slippery = 0.1;\")\n",
    "  log_print(\"// How likely is a rock a good rock\")\n",
    "  log_print(\"const double goodrock = 0.5;\")\n",
    "\n",
    "def primary_grid(lx, ly, rx, ry):\n",
    "  log_print(\"const int primaryMinX = {};\".format(lx))\n",
    "  log_print(\"const int primaryMinY = {};\".format(ly))\n",
    "  log_print(\"const int primaryMaxX = {};\".format(rx))\n",
    "  log_print(\"const int primaryMaxY = {};\".format(ry))\n",
    "  log_print(\"const int pad = 2;\")\n",
    "  log_print(\"const int areaMinX = max(primaryMinX - pad, xMIN);\")\n",
    "  log_print(\"const int areaMinY = max(primaryMinY - pad, yMIN);\")\n",
    "  log_print(\"const int areaMaxX = min(primaryMaxX + pad, xMAX);\")\n",
    "  log_print(\"const int areaMaxY = min(primaryMaxY + pad, yMAX);\")\n",
    "def rock_positions(obstacles, lx, ly, rx, ry):\n",
    "  for i, (x, y) in enumerate(obstacles):\n",
    "    if not in_bound((x, y), lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"const r{}x = {};\".format(i + 1, x))\n",
    "    log_print(\"const r{}y = {};\".format(i + 1, y))\n",
    "def constants(obstacles, lx, ly, rx, ry):\n",
    "  grid()\n",
    "  primary_grid(lx, ly, rx, ry)\n",
    "  rock_positions(obstacles, lx, ly, rx, ry)\n",
    "\n",
    "constants(obstacles, 0, 0, N -1 , N -1)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "FIBskBYxB6m5",
    "outputId": "2366bfbe-83e0-4d03-bab7-893385dbbf75"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "// We are done when we reach max x location\n",
      "formula finish = started & (!bad) & (x = xMAX | x = primaryMinX - 1 | x = primaryMinX - 2| y = primaryMinY - 1 | y = primaryMinY - 2 | x = primaryMaxX + 1 | x = primaryMaxX + 2| y = primaryMaxY + 1 | y = primaryMaxY + 2);\n",
      "observable \"seefinish\" = finish;\n",
      "formula maxdist = xMAX-xMIN+yMAX-yMIN;\n",
      "formula good = finish & done;\n",
      "formula r1dist = max(r1x-x,x-r1x) + max(r1y-y,y-r1y);\n",
      "formula r2dist = max(r2x-x,x-r2x) + max(r2y-y,y-r2y);\n",
      "formula bad = (r1dist=0 & !r1qual) | (r2dist=0 & !r2qual);\n",
      "formula normdistr1 = (r1dist <= 1) ? 1 : 2; // min(1+((r1dist-1)/maxdist), 1.0)\n",
      "formula normdistr2 = (r2dist <= 1) ? 1 : 2; // min(1+((r2dist-1)/maxdist), 1.0)\n",
      "observable \"atr1\" = r1dist <= 0;\n",
      "observable \"atr2\" = r2dist <= 0;\n",
      "observable \"nearr1\" = r1dist <= 1;\n",
      "observable \"nearr2\" = r2dist <= 1;\n",
      "observable \"seebad\" = bad;\n",
      "observable \"seegood\" = good;\n"
     ]
    }
   ],
   "source": [
    "def formula_finish(is_main):\n",
    "  log_print(\"// We are done when we reach max x location\")\n",
    "  if is_main:\n",
    "    log_print(\"formula finish = started & x = xMAX;\")\n",
    "  else:\n",
    "    string = \"formula finish = started & (!bad) & (x = xMAX | \";\n",
    "    out_primary_bound = \"x = primaryMinX - 1 | x = primaryMinX - 2| y = primaryMinY - 1 | y = primaryMinY - 2 | \"\n",
    "    out_primary_bound += \"x = primaryMaxX + 1 | x = primaryMaxX + 2| y = primaryMaxY + 1 | y = primaryMaxY + 2);\"\n",
    "    log_print(string + out_primary_bound)\n",
    "\n",
    "def observable_finish():\n",
    "  log_print(\"observable \\\"seefinish\\\" = finish;\")\n",
    "def formula_maxdist():\n",
    "  log_print(\"formula maxdist = xMAX-xMIN+yMAX-yMIN;\")\n",
    "\n",
    "def formula_good(is_main, R, obstacles, lx, ly, rx, ry):\n",
    "  if not is_main:\n",
    "    log_print(\"formula good = finish & done;\")\n",
    "    return\n",
    "  prefix = \"formula good = finish & done & (\"\n",
    "  ending = \");\"\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "def formula_dist(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"formula r{}dist = max(r{}x-x,x-r{}x) + max(r{}y-y,y-r{}y);\".format(i, i, i, i, i))\n",
    "  \n",
    "def formula_bad(R, obstacles, lx, ly, rx, ry):\n",
    "  prefix = \"formula bad = \"\n",
    "  ending  = \";\"\n",
    "  bad = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    bad.append(\"(r{}dist=0 & !r{}qual)\".format(i, i))\n",
    "  prefix += \" | \".join(bad) + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "def observable_at(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"observable \\\"atr{}\\\" = r{}dist <= 0;\".format(i, i))\n",
    "def observable_near(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"observable \\\"nearr{}\\\" = r{}dist <= 1;\".format(i, i))\n",
    "\n",
    "def formula_normdist(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"formula normdistr{} = (r{}dist <= 1) ? 1 : 2; // min(1+((r{}dist-1)/maxdist), 1.0)\".format(i, i, i))\n",
    "\n",
    "def observable_good_bad():\n",
    "  log_print(\"observable \\\"seebad\\\" = bad;\")\n",
    "  log_print(\"observable \\\"seegood\\\" = good;\")\n",
    "\n",
    "def formula_observable(R, is_main, obstacles, lx, ly, rx, ry):\n",
    "  formula_finish(is_main)\n",
    "  observable_finish()\n",
    "  formula_maxdist()\n",
    "  formula_good(is_main, R, obstacles, lx, ly, rx, ry)\n",
    "  formula_dist(R, obstacles, lx, ly, rx, ry)\n",
    "  formula_bad(R, obstacles, lx, ly, rx, ry)\n",
    "  formula_normdist(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_at(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_near(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_good_bad()\n",
    "formula_observable(R, False, obstacles, 0, 0, 7, 7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "5DCwt69cNAT4",
    "outputId": "141d7454-6712-4212-9893-a8da0d24d0e1"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "module master\n",
      "started : bool init false;\n",
      "done : bool init false;\n",
      "\n",
      "[placement] !started -> (started'=true);\n",
      "[north] started & !done -> true;\n",
      "[south] started  & !done -> true;\n",
      "[east] started  & !done-> true;\n",
      "[west] started & !done -> true;\n",
      "[finish] finish | done -> (done'=true);\n",
      "endmodule\n",
      "module robot\n",
      "x : [areaMinX..areaMaxX] init primaryMinX;\n",
      "y : [areaMinY..areaMaxX] init primaryMaxX;\n",
      "\n",
      "[west] true -> (1-slippery): (x'=max(x-1,areaMinX)) + slippery: (x'=max(x-2,areaMinX));\n",
      "[east] true -> (1-slippery): (x'=min(x+1,areaMaxX)) + slippery: (x'=min(x+2,areaMaxX));\n",
      "[south]  true -> (1-slippery): (y'=min(y+1,areaMaxY)) + slippery: (y'=min(y+2,areaMaxY));\n",
      "[north]  true -> (1-slippery): (y'=max(y-1,areaMinY)) + slippery: (y'=max(y-2,areaMinY));\n",
      "endmodule\n"
     ]
    }
   ],
   "source": [
    "def master():\n",
    "  log_print(\"module master\")\n",
    "  log_print(\"started : bool init false;\")\n",
    "  log_print(\"done : bool init false;\")\n",
    "  log_print(\"\")\n",
    "  log_print(\"[placement] !started -> (started\\'=true);\")\n",
    "  log_print(\"[north] started & !done -> true;\")\n",
    "  log_print(\"[south] started  & !done -> true;\")\n",
    "  log_print(\"[east] started  & !done-> true;\")\n",
    "  log_print(\"[west] started & !done -> true;\")\n",
    "  log_print(\"[finish] finish | done -> (done\\'=true);\")\n",
    "  log_print(\"endmodule\")\n",
    "def robot():\n",
    "  log_print(\"module robot\")\n",
    "  log_print(\"x : [areaMinX..areaMaxX] init primaryMinX;\")\n",
    "  log_print(\"y : [areaMinY..areaMaxX] init primaryMaxX;\")\n",
    "  log_print(\"\")\n",
    "  log_print(\"[west] true -> (1-slippery): (x\\'=max(x-1,areaMinX)) + slippery: (x\\'=max(x-2,areaMinX));\")\n",
    "  log_print(\"[east] true -> (1-slippery): (x\\'=min(x+1,areaMaxX)) + slippery: (x\\'=min(x+2,areaMaxX));\")\n",
    "  log_print(\"[south]  true -> (1-slippery): (y\\'=min(y+1,areaMaxY)) + slippery: (y\\'=min(y+2,areaMaxY));\")\n",
    "  log_print(\"[north]  true -> (1-slippery): (y\\'=max(y-1,areaMinY)) + slippery: (y\\'=max(y-2,areaMinY));\")\n",
    "  log_print(\"endmodule\")\n",
    "master()\n",
    "robot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "6h9KBsM_OHVX",
    "outputId": "e3f8e932-139b-4778-9f32-95aa4085d794"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "module rock1\n",
      "r1qual : bool init false;\n",
      "r1taken : bool init false;\n",
      "r1lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);\n",
      "\n",
      "[r1sample] r1dist = 0 & started & !done & !bad & !finish & !r1taken-> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));\n",
      "[r1sample] r1dist = 0 & started & !done & !bad & !finish & r1taken -> true;\n",
      "\n",
      "[r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);\n",
      "[north] true -> (r1lastobs'=false);\n",
      "[south] true -> (r1lastobs'=false);\n",
      "[east] true -> (r1lastobs'=false);\n",
      "[west] true -> (r1lastobs'=false);\n",
      "endmodule\n",
      "module rock2\n",
      "r2qual : bool init false;\n",
      "r2taken : bool init false;\n",
      "r2lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r2qual'=true) + (1-goodrock) : (r2qual'=false);\n",
      "\n",
      "[r2sample] r2dist = 0 & started & !done & !bad & !finish & !r2taken-> 1:(r2taken'=(x = r2x & y = r2y & !r2taken));\n",
      "[r2sample] r2dist = 0 & started & !done & !bad & !finish & r2taken -> true;\n",
      "\n",
      "[r2sense] started & !r2taken & !done & !bad & !finish -> (1/normdistr2): (r2lastobs'=r2qual) +  (1-(1/normdistr2)): (r2lastobs'=!r2qual);\n",
      "[north] true -> (r2lastobs'=false);\n",
      "[south] true -> (r2lastobs'=false);\n",
      "[east] true -> (r2lastobs'=false);\n",
      "[west] true -> (r2lastobs'=false);\n",
      "endmodule\n"
     ]
    }
   ],
   "source": [
    "def one_rock(k):\n",
    "  rk = \"r\" + str(k)\n",
    "  log_print(\"module rock1\".replace(\"1\", str(k)))\n",
    "  log_print(\"r1qual : bool init false;\".replace(\"r1\", rk))\n",
    "  log_print(\"r1taken : bool init false;\".replace(\"r1\", rk))\n",
    "  log_print(\"r1lastobs : bool init false;\".replace(\"r1\", rk))\n",
    "  log_print(\"[placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"\".replace(\"r1\", rk))\n",
    "  log_print(\"[r1sample] r1dist = 0 & started & !done & !bad & !finish & !r1taken-> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));\".replace(\"r1\", rk))\n",
    "  log_print(\"[r1sample] r1dist = 0 & started & !done & !bad & !finish & r1taken -> true;\".replace(\"r1\", rk))\n",
    "  log_print(\"\".replace(\"r1\", rk))\n",
    "  log_print(\"[r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);\".replace(\"r1\", rk))\n",
    "  log_print(\"[north] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"[south] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"[east] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"[west] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"endmodule\".replace(\"r1\", rk))\n",
    "def rocks(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    one_rock(i)\n",
    "rocks(R, obstacles, 0, 0, 7, 7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "id": "EtwQO_MfP5Kw"
   },
   "outputs": [],
   "source": [
    "def reward_cost(R, obstacles, lx, ly, rx, ry):\n",
    "  reward(R, obstacles, lx, ly, rx, ry)\n",
    "  cost(R, obstacles, lx, ly, rx, ry)\n",
    "\n",
    "def reward(R, obstacles, lx, ly, rx, ry, finishGood = 100, finish = 20):\n",
    "  log_print(\"rewards \\\"rew\\\"\")\n",
    "  sampleGood = 100\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"[r{}sample] r{}qual & !r{}taken : {};\".format(i, i, i, sampleGood))\n",
    "  \n",
    "  prefix = \"[finish] (\"\n",
    "  ending = \"): {};\".format(finishGood) ;\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "  log_print(\"[finish] true: {};\".format(finish))\n",
    "  log_print(\"endrewards\")\n",
    "\n",
    "def cost(R, obstacles, lx, ly, rx, ry, finishBad = 100, bad = 20):\n",
    "  \n",
    "  log_print(\"rewards \\\"cos\\\"\")\n",
    "  log_print(\"//[r1sample] !r1qual & !r1taken : 10; // no need; cause it won\\'t r1sample is not enabled if !r1qual\")\n",
    "  log_print(\"//[r2sample] !r2qual & !r1taken: 10; // no need; cause it won\\'t r1sample is not enabled if !r1qual\")\n",
    "  log_print(\"//[r1sample] r1taken : 20;\")\n",
    "  log_print(\"//[r2sample] r2taken : 20;\")\n",
    "  finishBad = 100\n",
    "  prefix = \"[finish] !(\"\n",
    "  ending = \"): {};\".format(finishBad) ;\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "  log_print(\"bad:{};\".format(20))\n",
    "  log_print(\"[east] true: 1;\")\n",
    "  log_print(\"[west] true: 1;\")\n",
    "  log_print(\"[north] true: 1;\")\n",
    "  log_print(\"[south] true: 1;\")\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"[r{}sense] true: 1;\".format(i))\n",
    "    \n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"[r{}sample] true: 1;\".format(i))\n",
    "  log_print(\"endrewards\")\n",
    "\n",
    "  log_print(\"rewards \\\"cost\\\"\")\n",
    "  log_print(\"[r1sense] true : 1;\")\n",
    "  log_print(\"[r1sample] !r1qual : 20;\")\n",
    "  log_print(\"[r2sense] true : 1;\")\n",
    "  log_print(\"[r2sample] !r2qual : 20;\")\n",
    "  log_print(\"//[r3sense] true : 1;\")\n",
    "  log_print(\"//[r3sample] !r3qual : 20;\")\n",
    "  log_print(\"[north] true : 1;\")\n",
    "  log_print(\"[south] true : 1;\")\n",
    "  log_print(\"[west] true : 1;\")\n",
    "  log_print(\"[east] true : 1;\")\n",
    "  log_print(\"[finish] true : (!r1taken & r1qual ? 30 : 0) + (!r2taken & r2qual ? 30 : 0) ;//+ (!r3taken & r3qual ? 30 : 0) ;\")\n",
    "  log_print(\"endrewards\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "id": "BG_-bFfSWKrf"
   },
   "outputs": [],
   "source": [
    "def labels(R, obstacles, lx, ly, rx, ry):\n",
    "  log_print(\"label \\\"notbad\\\" = !bad;\")\n",
    "  log_print(\"label \\\"goal\\\" = good;\")\n",
    "  prefix = \"label \\\"rockposition\\\" = \"\n",
    "  ending = \";\"\n",
    "  position = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    position.append(\"(!r{}taken & r{}x = x & r{}y = y)\".format(i, i, i))\n",
    "  log_print(prefix + \" | \".join(position) + ending)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "id": "9dqRGT3KVF7P"
   },
   "outputs": [],
   "source": [
    "def generate_file(N, R, is_main, lx, ly, rx, ry):\n",
    "  obstacles = generate_rocks(N, R)\n",
    "  preamble(R, obstacles, lx, ly, rx, ry)\n",
    "  constants(obstacles, lx, ly, rx, ry)\n",
    "  formula_observable(R, is_main, obstacles, lx, ly, rx, ry)\n",
    "  master()\n",
    "  robot()\n",
    "  rocks(R, obstacles, lx, ly, rx, ry)\n",
    "  labels(R, obstacles, lx, ly, rx, ry)\n",
    "  reward_cost(R, obstacles, lx, ly, rx, ry)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'cap' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Input \u001b[0;32mIn [15]\u001b[0m, in \u001b[0;36m<cell line: 1>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      1\u001b[0m \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28mopen\u001b[39m(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124moutputd.txt\u001b[39m\u001b[38;5;124m'\u001b[39m, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mw\u001b[39m\u001b[38;5;124m'\u001b[39m) \u001b[38;5;28;01mas\u001b[39;00m f:\n\u001b[0;32m----> 2\u001b[0m     f\u001b[38;5;241m.\u001b[39mwrite(\u001b[43mcap\u001b[49m\u001b[38;5;241m.\u001b[39mstdout)\n\u001b[1;32m      3\u001b[0m f\u001b[38;5;241m.\u001b[39mclose()\n",
      "\u001b[0;31mNameError\u001b[0m: name 'cap' is not defined"
     ]
    }
   ],
   "source": [
    "%%capture cap --no-stderr\n",
    "with open('outputd.txt', 'w') as f:\n",
    "    f.write(cap.stdout)\n",
    "f.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "id": "DbddqkCnnAGy"
   },
   "outputs": [],
   "source": [
    "N = 8\n",
    "R = 4\n",
    "obstacles = generate_rocks(N, R)\n",
    "\n",
    "xMIN = yMIN = 0\n",
    "xMAX = yMAX = N - 1\n",
    "\n",
    "#generate_file(N, R, True, xMIN, yMIN, xMAX, yMAX)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {
    "id": "u_vrQSUrQIuL"
   },
   "outputs": [],
   "source": [
    "%%capture cap --no-stderr\n",
    "\n",
    "shieldSize = 4\n",
    "shieldSizeX = 4\n",
    "shieldSizeY = 4   \n",
    "for lx in range(0, xMAX, shieldSizeX):\n",
    "  for ly in range(0, yMAX, shieldSizeY):\n",
    "    rx, ry = lx + shieldSizeX - 1, ly + shieldSizeY - 1\n",
    "    file_name = \"rock_N{}R{}-{}-{}-{}-{}-{}.nm\".format(N, R, shieldSize, lx, ly, rx, ry)\n",
    "    with open(file_name, 'w') as f:\n",
    "        f.write(cap.stdout)\n",
    "    generate_file(N, R, False, lx, ly, rx, ry)\n",
    "    f.close()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Line1: Geeks\n",
      "Line2: for\n",
      "Line3: Geeks\n"
     ]
    }
   ],
   "source": [
    "\n",
    "# Python code to\n",
    "# demonstrate readlines()\n",
    "  \n",
    "L = [\"Geeks\\n\", \"for\\n\", \"Geeks\\n\"]\n",
    "  \n",
    "# writing to file\n",
    "file1 = open('myfile.txt', 'w')\n",
    "file1.writelines(L)\n",
    "file1.close()\n",
    "  \n",
    "# Using readlines()\n",
    "file1 = open('myfile.txt', 'r')\n",
    "Lines = file1.readlines()\n",
    "  \n",
    "count = 0\n",
    "# Strips the newline character\n",
    "for line in Lines:\n",
    "    count += 1\n",
    "    if \"print(\" in line:\n",
    "        print(line)\n",
    "    print(\"Line{}: {}\".format(count, line.strip()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "write_file = open('rocks_copy.py', 'w')\n",
    "read_file = open('rocks.py', 'r')\n",
    "lines = read_file.readlines()\n",
    "for line in lines:\n",
    "    if \"print(\" in line:\n",
    "        line = line[:-2] + \", file = f)\\n\"\n",
    "    if \"def\" in line:\n",
    "        line = line[:-3] + \", file = sys.stdout):\\n\"\n",
    "    if \"(, \" in line:\n",
    "        line = line.replace(\"(, \", \"(\")\n",
    "    write_file.writelines(line)\n",
    "read_file.close()\n",
    "write_file.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%capture cap --no-stderr\n",
    "with open('output.txt', 'w') as f:\n",
    "    f.write(cap.stdout)\n",
    "f.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 514
    },
    "id": "wcDkWYlSfh1L",
    "outputId": "83d770d0-3ab5-4685-d537-00e72d71bc8b"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[(1, 2), (3, 0), (3, 5), (6, 2)]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x576 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "obstacles = generate_rocks(N, R)\n",
    "log_print(obstacles)\n",
    "plot_board(obstacles, [], None, 8)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "id": "cdU1e5cu1cnv"
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 200
    },
    "id": "oNWrbXMFH3xU",
    "outputId": "8cdb033b-cea1-41c4-c56d-14dd5e8f4342"
   },
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'obstacle' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Input \u001b[0;32mIn [20]\u001b[0m, in \u001b[0;36m<cell line: 1>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0m plot_board(\u001b[43mobstacle\u001b[49m, [((\u001b[38;5;241m2\u001b[39m,\u001b[38;5;241m3\u001b[39m))],  agent, N)\n",
      "\u001b[0;31mNameError\u001b[0m: name 'obstacle' is not defined"
     ]
    }
   ],
   "source": [
    "plot_board(obstacle, [((2,3))],  agent, N)\n",
    "#plot_board(obstacle, [(2,3),(2,1)],  agent, N)\n",
    "#plot_board(obstacle, [(4,4)],  agent, N)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Ay8FHPMtthhe"
   },
   "outputs": [],
   "source": [
    "obstacle = [(1, 0), (5, 1),  (2, 4), (4, 4), (5,4), (5,5)]\n",
    "belief = [(2, 1), (1, 1),  (1, 3), (3,4)]\n",
    "agent= (2,1)\n",
    "N = 6\n",
    "plot_board(obstacle, belief, agent, N)\n",
    "\n",
    "s, w, e, n = 's', 'w', 'e', 'n'\n",
    "for action in [s, e, e, s, e,  e]:\n",
    "  belief = move(belief, action)\n",
    "  plot_board(obstacle, belief, agent, N)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Zn85QTTVok1R"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "eLFV1WF2juHF"
   },
   "outputs": [],
   "source": [
    "\n",
    "path = \"/content/drive/MyDrive/2021-03-25 MO-POMDP/shielding/\"\n",
    "prism_file = \"Shili todo list - MO-POMDP - Sheet6.csv\"\n",
    "stompy_file = \"Shili todo list - MO-POMDP - Sheet5.csv\"\n",
    "prism = pd.read_csv(path + prism_file)\n",
    "stompy = pd.read_csv(path + stompy_file)\n",
    "stompy = stompy.loc[:, ['s', 'o', 'x', 'y', 'r1qual', 'r1taken', 'r1lastobs', 'r2qual', 'r2taken', 'r2lastobs']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Qy1sAAGqoIxu"
   },
   "outputs": [],
   "source": [
    "prism.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "HZqJPUJuljsP"
   },
   "outputs": [],
   "source": [
    "data = prism\n",
    "feature = \"obs\"\n",
    "for i in range(len(data)):\n",
    "  obs = data.loc[i, feature]\n",
    "  obs_size = len(data.loc[data.loc[:, feature] == obs, :])\n",
    "  data.loc[i, \"obs_size\"] = obs_size\n",
    "\n",
    "data = stompy\n",
    "feature = \"o\"\n",
    "for i in range(len(data)):\n",
    "  obs = data.loc[i, feature]\n",
    "  obs_size = len(data.loc[data.loc[:, feature] == obs, :])\n",
    "  data.loc[i, \"obs_size\"] = obs_size\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "tbzk_wrKkBXW"
   },
   "outputs": [],
   "source": [
    "for i in range(10):\n",
    "  c1 = prism.r1qual == stompy.loc[i, \"r1qual\"]\n",
    "  c2 = prism.r1taken == stompy.loc[i, \"r1taken\"]\n",
    "  c3 = prism.x == stompy.loc[i, \"x\"]\n",
    "  c4 = prism.y == stompy.loc[i, \"y\"]\n",
    "  c5 = prism.obs_size == stompy.loc[i, \"obs_size\"]\n",
    "  c6 = prism.r2qual == stompy.loc[i, \"r2qual\"]\n",
    "  c7 = prism.r2taken == stompy.loc[i, \"r2taken\"]\n",
    "\n",
    "  condition = c1 & c2 & c3 & c4 & c6 & c7\n",
    "  tp = prism.loc[condition, :]\n",
    "\n",
    "  sc1 = stompy.r1qual == stompy.loc[i, \"r1qual\"]\n",
    "  sc2 = stompy.r1taken == stompy.loc[i, \"r1taken\"]\n",
    "  sc3 = stompy.x == stompy.loc[i, \"x\"]\n",
    "  sc4 = stompy.y == stompy.loc[i, \"y\"]\n",
    "  sc5 = stompy.obs_size == stompy.loc[i, \"obs_size\"]\n",
    "  sc6 = stompy.r2qual == stompy.loc[i, \"r2qual\"]\n",
    "  sc7 = stompy.r2taken == stompy.loc[i, \"r2taken\"]\n",
    "  scondition = sc1 & sc2 & sc3 & sc4 & sc5 & sc6 &sc7\n",
    "  stp = stompy.loc[scondition, :]\n",
    "  #c1 = prism.r1qual == stompy.loc[i, \"r1qual\"]\n",
    "  log_print(stompy.loc[i,:])\n",
    "  log_print(tp) \n",
    "  log_print(stp) \n",
    "  log_print(\"++++++++++++++++++++++++++\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "j0AFWI2O55fq"
   },
   "outputs": [],
   "source": [
    "def bitfield(n):\n",
    "  tp =[int(digit) for digit in bin(n)[2:]]\n",
    "  while len(tp)<64:\n",
    "    tp.insert(0,0)\n",
    "  return tp# [2:] to chop off the \"0b\" part "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "F7QIoVp2m-e8"
   },
   "outputs": [],
   "source": [
    "nums = [16167922662260080640,9223372036854775808,18410715276690587648 ]\n",
    "for n in nums:\n",
    "  log_print(bitfield(n))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Q5r8aBFY5-k9"
   },
   "outputs": [],
   "source": [
    "a = [ 13546120693153792]\n",
    "un = []\n",
    "for i in range(len(a)):\n",
    "  startIndex = 0 if (i % 2 ==0) else 64\n",
    "  tp = bitfield(a[i])\n",
    "  un2 = []\n",
    "  for j in range(len(tp)):\n",
    "    if (tp[j]==1):\n",
    "      un2.append(j + startIndex)\n",
    "      un.append(j + startIndex)\n",
    "  log_print(un2)\n",
    "un.sort()\n",
    "log_print(un)\n",
    "\n",
    "#[3 13 14 15 28 30 31 36 51 53 59 64 72 73 82 83 ]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "kEHeF4GxnNMe"
   },
   "outputs": [],
   "source": [
    "log_print(bitfield(4608))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "W1uvzP8-m4LP"
   },
   "outputs": [],
   "source": [
    "bucket1 = []\n",
    "bucket2 = []\n",
    "index = [54, 72, 72, 74, 74, 82, 82, 53, 55, 55, 73, 73, 75, 75, 83, 52, 54] \n",
    "for i in index:\n",
    "  if (i >=64):\n",
    "    bucket2.append(i) \n",
    "  else:\n",
    "    bucket1.append(i)\n",
    "log_print(bucket1)\n",
    "log_print(bucket2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ot_CFXDAnQkG"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "im8reSETIkDd"
   },
   "outputs": [],
   "source": [
    "\n",
    "un = set()\n",
    "a=[4608, 135195949751336960]\n",
    "for i in a:\n",
    "  un2 = set()\n",
    "  log_print(bitfield(i),  len(bitfield(i)))\n",
    "  tp = bitfield(i)\n",
    "  for j in range(len(tp)):\n",
    "    if (tp[j] == 1):\n",
    "      un.add(j)\n",
    "      un2.add(j)\n",
    "  log_print(un2)\n",
    "un = (list(un))\n",
    "un.sort()\n",
    "log_print(un, len(un))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "pAPZqBYgcXM8"
   },
   "outputs": [],
   "source": [
    "[3 13 14 15 28 30 31 36 51 53 59 64 72 73 82 83 ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "eES9qpMG2FFa"
   },
   "outputs": [],
   "source": [
    "def nextPosition(cur, a):\n",
    "    if a == 'n':\n",
    "      return cur + 10\n",
    "    elif a == 'w':\n",
    "      return cur - 1\n",
    "    elif a == 's':\n",
    "      return cur - 10\n",
    "    elif a =='e':\n",
    "      return cur +1\n",
    "    else:\n",
    "      return -1\n",
    "def inBound(next):\n",
    "    if (next<0):\n",
    "      return False\n",
    "    x = int(next/10)\n",
    "    y = next % 10\n",
    "    return (x<=9) & (x>=0) & (y<=9) & (y>=0)\n",
    "def transition():\n",
    "    x = 10\n",
    "    y = 10\n",
    "    var = \"loc\"\n",
    "    actions = ['n', 'w', 's', 'e']\n",
    "    log_print(\"module agent\")\n",
    "    log_print(var+\": [0:\"+ str(x*y)+\"] init 0;\")\n",
    "    for i in range(x):\n",
    "      for j in range(y):\n",
    "        cur = int(i*10+j)\n",
    "\n",
    "        for a in actions:\n",
    "          nextPositions = np.zeros(5)\n",
    "          nextPositionsProbs = np.zeros(5)\n",
    "          for k in range(len(actions)):\n",
    "            act_prob = actions[k]\n",
    "            prob = 0.7 if a==act_prob else 0.1\n",
    "            next = nextPosition(cur, act_prob)\n",
    "            nextPositions[k+1] = next\n",
    "            if inBound(next):\n",
    "              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob\n",
    "        \n",
    "          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur\n",
    "          nextPositions = nextPositions.astype(int)\n",
    "          rule = \"\"\n",
    "          for k in range(len(nextPositionsProbs)):\n",
    "            if nextPositionsProbs[k]>0 :\n",
    "              rule += str(nextPositionsProbs[k])[0:3] + \":(\" + var +\"'=\"+str(nextPositions[k]) +\")+\"\n",
    "          rule = rule[:-1] + \";\"\n",
    "          log_print(\"[\"+a+\"]\", var+\"=\"+str(cur), \"->\", rule)\n",
    "    log_print(\"enmodule\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Oank8dn91mnE"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "cfoAMwlAsZ4J"
   },
   "outputs": [],
   "source": [
    "def model():\n",
    "  log_print(\"pomdp\")\n",
    "def observables(var_obs):\n",
    "  log_print(\"observables \"+var_obs+\" endobservables\")\n",
    "def label(var_obs):\n",
    "  log_print(\"label \\\"end\\\" = \"+var_obs+\"= 100;\")\n",
    "def rewards(var,var2):\n",
    "  log_print(\"rewards \\\"dd\\\"\")\n",
    "  log_print(\"\\t\"+var+\" = 0 : 10;\")\n",
    "  log_print(\"endrewards\")\n",
    "def nextPosition(cur, a):\n",
    "  next = cur.copy()\n",
    "  if a == 'n':\n",
    "     next[1] += 1\n",
    "  elif a == 'w':\n",
    "    next[0] -= 1\n",
    "  elif a == 's':\n",
    "    next[1] -= 10\n",
    "  elif a =='e':\n",
    "    next[0] += 1\n",
    "  return next\n",
    "def state(cur):\n",
    "  return str(int(cur[0]*10+cur[1]))\n",
    "def inBound(next, xMax, yMax):\n",
    "  x = next[0]\n",
    "  y = next[1]\n",
    "  return (x<xMax) & (x>=0) & (y<yMax) & (y>=0)\n",
    "def obsF(cur, xMax, yMax):\n",
    "  directions = [  [-1,1], [0,1],[1,1],\n",
    "                [-1,0], [0,0], [1,0], \n",
    "                [-1,-1], [0,-1],[1,-1]]\n",
    "  #directions =[[1,0], [0,0]]\n",
    "  n_neighbor = len(directions)\n",
    "  neighbors = [0]*n_neighbor\n",
    "  probs = np.ones(n_neighbor)\n",
    "\n",
    "                   \n",
    "  for direction in range(len(directions)):\n",
    "    next = np.sum([cur, directions[direction]], axis= 0)\n",
    "    neighbors[direction] = next\n",
    "    if not inBound(next, xMax, yMax):\n",
    "      probs[direction] = 0\n",
    "  sum_probs = np.sum(probs)\n",
    "  for i in range(n_neighbor):\n",
    "    probs[i] /= sum_probs\n",
    "\n",
    "  result = [neighbors, probs]\n",
    "  return result\n",
    "def transition( xMax, yMax, targetX, targetY):\n",
    "  x = xMax\n",
    "  y = yMax\n",
    "  \n",
    "  var = \"location\"\n",
    "  var2 = \"obsLocation\"\n",
    "  model()\n",
    "  observables(var2)\n",
    "\n",
    "  actions = ['n', 'w', 's', 'e']\n",
    "  log_print(\"module agent\")\n",
    "  log_print(var+\": [0.. 100] init 0;\")\n",
    "  log_print(var2+\": [0.. 100] init 0;\")\n",
    "  for i in range(x):\n",
    "    for j in range(y):\n",
    "      cur = [i ,j].copy()\n",
    "      if i==targetX and j == targetY:\n",
    "        log_print(\"[n] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "        log_print(\"[s] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "        log_print(\"[w] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "        log_print(\"[e] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "      else:\n",
    "        for a in actions:\n",
    "          nextPositions = [None]* (len(actions)+1)\n",
    "          nextPositionsProbs = [0]* (len(actions)+1)\n",
    "          for k in range(len(actions)):\n",
    "            act_prob = actions[k]\n",
    "            prob = 0.7 if a==act_prob else 0.1\n",
    "            next = nextPosition(cur, act_prob)\n",
    "            nextPositions[k+1] = next\n",
    "            if inBound(next, xMax, yMax):\n",
    "              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob\n",
    "        \n",
    "          nextPositions[0] = cur\n",
    "          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur\n",
    "          pre_rule = \"[\"+a+\"] \"+ var+\"=\"+state(cur)+ \" -> \"\n",
    "          rule = \"\"\n",
    "          ruleB = \"\"\n",
    "          for k in range(len(nextPositionsProbs)):\n",
    "            prob_a = nextPositionsProbs[k]\n",
    "            if prob_a >0 :\n",
    "              rule += str(nextPositionsProbs[k])[0:3] + \":(\" + var +\"'=\"+state(nextPositions[k]) +\")+\"\n",
    "              \n",
    "              observations, observations_probs = obsF(nextPositions[k], xMax, yMax)\n",
    "              for l in range(len(observations)):\n",
    "                prob_b = observations_probs[l]\n",
    "                if prob_b>0:\n",
    "                  ruleB += str(prob_a* prob_b) + \":(\" + var + \"'=\" + state(nextPositions[k]) + \")\" + \" & (\"+var2+\"'=\" + state(observations[l]) + \")+\"     \n",
    "          \n",
    "          rule = rule[:-1] + \";\"\n",
    "          ruleB = ruleB[:-1]+\";\"\n",
    "          #log_print(\"\"+ pre_rule+rule)\n",
    "          log_print( pre_rule+ruleB)\n",
    "  log_print(\"endmodule\")\n",
    "  label(var2)\n",
    "  rewards(var, var2)\n",
    "transition(5,5, 4,4)   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "902QoeCrosSQ"
   },
   "outputs": [],
   "source": [
    "def model():\n",
    "  log_print(\"pomdp\")\n",
    "def observables(var_obs):\n",
    "  log_print(\"observables obsX obsY endobservables\")\n",
    "def label(var_obs):\n",
    "  log_print(\"label \\\"end\\\" = x =10 & y = 10;\")\n",
    "def rewards(var,var2):\n",
    "  log_print(\"rewards \\\"dd\\\"\")\n",
    "  log_print(\"\\t x = 10 & y = 10 : 1;\")\n",
    "  log_print(\"endrewards\")\n",
    "def nextPosition(cur, a):\n",
    "  next = cur.copy()\n",
    "  if a == 'n':\n",
    "     next[1] += 1\n",
    "  elif a == 'w':\n",
    "    next[0] -= 1\n",
    "  elif a == 's':\n",
    "    next[1] -= 10\n",
    "  elif a =='e':\n",
    "    next[0] += 1\n",
    "  return next\n",
    "def state(cur):\n",
    "  return str(int(cur[0]*10+cur[1]))\n",
    "def inBound(next, xMax, yMax):\n",
    "  x = next[0]\n",
    "  y = next[1]\n",
    "  return (x<xMax) & (x>=0) & (y<yMax) & (y>=0)\n",
    "def obsF(cur, xMax, yMax):\n",
    "  directions = [  [-1,1], [0,1],[1,1],\n",
    "                [-1,0], [0,0], [1,0], \n",
    "                [-1,-1], [0,-1],[1,-1]]\n",
    "  directions =[[1,0], [0,0]]\n",
    "  n_neighbor = len(directions)\n",
    "  neighbors = [0]*n_neighbor\n",
    "  probs = np.ones(n_neighbor)\n",
    "\n",
    "                   \n",
    "  for direction in range(len(directions)):\n",
    "    next = np.sum([cur, directions[direction]], axis= 0)\n",
    "    neighbors[direction] = next\n",
    "    if not inBound(next, xMax, yMax):\n",
    "      probs[direction] = 0\n",
    "  sum_probs = np.sum(probs)\n",
    "  for i in range(n_neighbor):\n",
    "    probs[i] /= sum_probs\n",
    "\n",
    "  result = [neighbors, probs]\n",
    "  return result\n",
    "def transition( xMax, yMax, targetX, targetY):\n",
    "  x = xMax\n",
    "  y = yMax\n",
    "  \n",
    "  var = \"location\"\n",
    "  var2 = \"obsLocation\"\n",
    "  model()\n",
    "  observables(var2)\n",
    "\n",
    "  actions = ['n', 'w', 's', 'e']\n",
    "  log_print(\"module agent\")\n",
    "  log_print(\"x\"+\": [0.. 100] init 0;\")\n",
    "  log_print(\"y\"+\": [0.. 100] init 0;\")\n",
    "  log_print(\"obsX\"+\": [0.. 100] init 0;\")\n",
    "  log_print(\"obsY\"+\": [0.. 100] init 0;\")\n",
    "  for i in range(x):\n",
    "    for j in range(y):\n",
    "      cur = [i ,j].copy()\n",
    "      if i==targetX and j == targetY:\n",
    "        tp = \"[n] x=targetX & y=targetY : (x'=100)&(y'=100)&(obsX'=100)&(obsY=100)\"\n",
    "        tp = tp.replace(\"targetX\",str(targetX)).replace(\"targetY\",str(targetY))\n",
    "        log_print(tp)\n",
    "        log_print(tp.replace(\"[n]\",\"[w]\"))\n",
    "        log_print(tp.replace(\"[n]\",\"[s]\"))\n",
    "        log_print(tp.replace(\"[n]\",\"[e]\"))\n",
    "      else:\n",
    "        for a in actions:\n",
    "          nextPositions = [None]* (len(actions)+1)\n",
    "          nextPositionsProbs = [0]* (len(actions)+1)\n",
    "          for k in range(len(actions)):\n",
    "            act_prob = actions[k]\n",
    "            prob = 0.7 if a==act_prob else 0.1\n",
    "            next = nextPosition(cur, act_prob)\n",
    "            nextPositions[k+1] = next\n",
    "            if inBound(next, xMax, yMax):\n",
    "              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob\n",
    "        \n",
    "          nextPositions[0] = cur\n",
    "          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur\n",
    "          pre_rule = \"[\"+a+\"] \" + \"x=\"+str(cur[0])+ \" & y=\"+str(cur[1])+ \"-> \"\n",
    "          rule = \"\"\n",
    "          ruleB = \"\"\n",
    "          for k in range(len(nextPositionsProbs)):\n",
    "            prob_a = nextPositionsProbs[k]\n",
    "            if prob_a >0 :\n",
    "              rule += str(nextPositionsProbs[k])[0:3] + \":(\" + var +\"'=\"+state(nextPositions[k]) +\")+\"\n",
    "              \n",
    "              observations, observations_probs = obsF(nextPositions[k], xMax, yMax)\n",
    "              for l in range(len(observations)):\n",
    "                prob_b = observations_probs[l]\n",
    "                if prob_b>0:\n",
    "                  nxtX = str(nextPositions[k][0])\n",
    "                  nxtY = str(nextPositions[k][1])\n",
    "                  nxtX_obs = str(observations[l][0])\n",
    "                  nxtY_obs = str(observations[l][1])\n",
    "                  #ruleB += str(prob_a* prob_b) + \":(\" + var + \"'=\" + state(nextPositions[k]) + \")\" + \" & (\"+var2+\"'=\" + state(observations[l]) + \")+\"     \n",
    "                  tp = \"prob_a*prob_b : (x'=nxtX)&(y'=nxtY)&(obsX'=nxtX_obs)&(obsY'=nxtY_obs) +\"\n",
    "                  tp = tp.replace(\"prob_a*prob_b\", str(prob_a*prob_b))\n",
    "                  tp = tp.replace(\"nxtX_obs\", nxtX_obs).replace(\"nxtY_obs\", nxtY_obs)\n",
    "\n",
    "                  tp = tp.replace(\"nxtX\", nxtX).replace(\"nxtY\", nxtY)\n",
    "                  ruleB += tp\n",
    "          rule = rule[:-1] + \";\"\n",
    "          ruleB = ruleB[:-1]+\";\"\n",
    "          #log_print(\"\"+ pre_rule+rule)\n",
    "          log_print( pre_rule+ruleB)\n",
    "  log_print(\"endmodule\")\n",
    "  label(var2)\n",
    "  rewards(var, var2)\n",
    "transition(3,3, 2,2)   "
   ]
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "name": "generate blind grid for Prism",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
