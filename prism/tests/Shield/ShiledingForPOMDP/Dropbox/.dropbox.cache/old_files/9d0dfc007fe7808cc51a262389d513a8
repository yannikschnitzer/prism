pomdp
observables
start
endobservables

const int N = 6;
const int ENERGY = 8 ;
const int RESOLUTION = 2;
const int fuelCAP = ENERGY;
const int axMAX = N-1;
const int ayMAX = N-1;
const int axMIN = 0;
const int ayMIN = 0;
const double slippery = 0.3;
const int primaryMinX = 3;
const int primaryMinY = 0;
const int primaryMaxX = 5;
const int primaryMaxY = 2;
const int borderSize = 2;
const int areaMinX = max(primaryMinX - borderSize, axMIN);
const int areaMinY = max(primaryMinY - borderSize, ayMIN);
const int areaMaxX = min(primaryMaxX + borderSize, axMAX);
const int areaMaxY = min(primaryMaxY + borderSize, ayMAX);
const int ob1x = 4;
const int ob1y = 4;
const int rf1x = 0;
const int rf1y = 0;
const int rf2x = 2;
const int rf2y = 2;
const int rf3x = 3;
const int rf3y = 3;

formula distance = axMAX - ax + ayMAX - ay;
formula distrf1 = max(rf1x - ax, ax - rf1x) + max(rf1y - ay, ay - rf1y);
formula westenabled = ax != axMIN;
formula eastenabled = ax != axMAX;
formula northenabled = ay != ayMIN;
formula southenabled = ay != ayMAX;
observable "cangonorth" = northenabled;
observable "cangosouth" = southenabled;
observable "cangowest" = westenabled;
observable "cangoeast" = eastenabled;
formula done = start & (!crash) & ((ax = axMAX & ay = ayMAX) | ax = primaryMaxX + 1 | ax = primaryMaxX + 2 | ay = primaryMaxY + 1 | ay = primaryMaxY + 2 |ax = primaryMinX - 1 | ax = primaryMinX - 2 | ay = primaryMinY - 1 | ay = primaryMinY - 2 ) ;
observable "amdone" = done;
formula crash =start & ((ax = ob1x & ay = ob1y));
formula atStation =start & ((ax = rf2x & ay = rf2y) | (ax = rf3x & ay = rf3y));
formula canRefuel = atStation  & fuel < fuelCAP;
observable "hascrash" = crash;
observable "refuelAllowed" = canRefuel;
observable "fuelempty" = fuel > 0;
observable "fuelfull" = fuel = ENERGY;
observable "fuelmeter" = floor(fuel/(ENERGY/RESOLUTION));

module master
start : bool init false;

[placement] !start -> (start'=true);
[north] start & !done -> true;
[south] start  & !done -> true;
[east] start  & !done-> true;
[west] start & !done -> true;
[done] start & done -> true;
endmodule

module tank
fuel : [0..fuelCAP] init fuelCAP;

[placement] true -> 1/9: (fuel'=0) + 1/9: (fuel'=1) + 1/9: (fuel'=2) + 1/9: (fuel'=3) + 1/9: (fuel'=4) + 1/9: (fuel'=5) + 1/9: (fuel'=6) + 1/9: (fuel'=7) + 1/9: (fuel'=8);
[refuel] canRefuel -> 1:(fuel'=fuelCAP);
[north] fuel > 0 & !canRefuel -> 0.7:(fuel'=fuel-1) + 0.3:(fuel'=max(fuel-1,0));
[south] fuel > 0 & !canRefuel -> 0.7:(fuel'=fuel-1)+ 0.3:(fuel'=max(fuel-1,0));
[east] fuel > 0 & !canRefuel -> 0.7:(fuel'=fuel-1)+ 0.3:(fuel'=max(fuel-1,0));
[west] fuel > 0 & !canRefuel -> 0.7:(fuel'=fuel-1)+ 0.3:(fuel'=max(fuel-1,0));
[empty] fuel = 0 & !canRefuel -> 1:(fuel'=0);
endmodule

module rover
ax : [0..axMIN] init areaMinX;
ay : [0..ayMIN] init areaMinY;
[placement] true ->1:(ax'=primaryMinX+1) & (ay'=primaryMinY);
//[west] westenabled & ax!=4-> (1-slippery): (ax'=max(ax-1,axMIN)) + slippery: (ax'=max(ax-2,axMIN));
[west] westenabled & ax=4-> (1-slippery): (ax'=3) + slippery: (ax'=2);

[east] eastenabled -> (1-slippery): (ax'=min(ax+1,axMAX)) + slippery: (ax'=min(ax+2,axMAX));
[south]  southenabled -> (1-slippery): (ay'=min(ay+1,ayMAX)) + slippery: (ay'=min(ay+2,ayMAX));
[north]  northenabled -> (1-slippery): (ay'=max(ay-1,ayMIN)) + slippery: (ay'=max(ay-2,ayMIN));
endmodule

rewards "steps"
[north] true : 1;
[south] true : 1;
[west] true : 1;
[east] true : 1;
endrewards

rewards "refuels"
[refuel] true : 1;
endrewards

rewards "cost"
[north] true : 1;
[south] true : 1;
[west] true : 1;
[east] true : 1;
[refuel] true : 3;
endrewards

rewards "reward"
done : 10;
endrewards
label "goal" = done & (fuel >= distance | atStation | fuel >= distrf1);
label "traps" = crash;
label "stationvisit" = atStation;
label "notbad" =  !crash & (fuel > 0 | canRefuel);
