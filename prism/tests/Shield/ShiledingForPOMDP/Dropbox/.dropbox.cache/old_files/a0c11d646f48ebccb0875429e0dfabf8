{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "f3172a99",
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (2034694739.py, line 84)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  Input \u001b[0;32mIn [1]\u001b[0;36m\u001b[0m\n\u001b[0;31m    def grid(, file = sys.stdout):\u001b[0m\n\u001b[0m             ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "\n",
    "def plot_board(obstacle, beliefState, agent, N, file = sys.stdout):\n",
    "\n",
    "  from matplotlib import pyplot as plt\n",
    "  fig, ax = plt.subplots(figsize = (N,N))\n",
    "  ax.xaxis.set_ticks_position('top')   #将X坐标轴移到上面\n",
    "  ax.invert_yaxis()  \n",
    "  #\n",
    "  x = [i for i in range(N)]\n",
    "  y = [i for i in range(N)]\n",
    "  plt.xlim((0,N))\n",
    "  #plt.ylim((0,N))\n",
    "  ax.set_ylim(bottom=N, top=0)  # 此处将原点设置为左上角  \n",
    "  plt.xticks([0.5 + i for i in range(N )], labels = [str(i) for i in range(N)])\n",
    "  plt.yticks([0.5 + i for i in range(N)], labels = [str(i) for i in range(N)])\n",
    "  plt.xlabel('X Axis')\n",
    "  plt.ylabel('Y Axis')\n",
    "  width = 1\n",
    "  height =1 \n",
    "\n",
    "  for left, bottom in obstacle:\n",
    "    rect = plt.Rectangle((left, bottom), width, height, facecolor=\"red\", alpha = 1)\n",
    "    ax.add_patch(rect)\n",
    "\n",
    "  for left, bottom in beliefState:\n",
    "    rect = plt.Rectangle((left, bottom), width, height, facecolor=\"blue\", alpha = 0.5)\n",
    "    ax.add_patch(rect)\n",
    "\n",
    "  #plt.scatter(agent[0] + 0.5, agent[1] +0.5)\n",
    "  for i in range(N):\n",
    "    plt.hlines(i, 0, N , alpha = 0.5)\n",
    "    plt.vlines(i, 0, N , alpha = 0.5)\n",
    "  plt.grid(False)\n",
    "  plt.show()\n",
    "\n",
    "\n",
    "def move(belief, action, file = sys.stdout):\n",
    "  result = set()\n",
    "  for x, y in belief:\n",
    "    for slip in [1, 2]:\n",
    "      if action == \"w\":\n",
    "        nx, ny = max(0, x - slip) , y\n",
    "      if action == 'e':\n",
    "        nx, ny = min(N - 1, x + slip), y\n",
    "      if action == 'n':\n",
    "        nx, ny = x, max(0, y - slip)\n",
    "      if action == 's':\n",
    "        nx, ny = x, min(N - 1, y + slip)\n",
    "      result.add((nx, ny))\n",
    "  return list(result)\n",
    "\n",
    "def generate_rocks(N, R, file = sys.stdout):\n",
    "  obstacles = set()\n",
    "  import random\n",
    "  random.seed(N)\n",
    "  while len(obstacles) < R:\n",
    "    obstacle = (random.randint(0, N - 1), random.randint(0, N - 1))\n",
    "    if obstacle == (0, 0):\n",
    "      continue\n",
    "    obstacles.add(obstacle)\n",
    "  if N == 7:\n",
    "    obstacles = [(1, 1), (1, 2), (2, 1), (3, 3), (3, 5), (4, 0), (4, 1), (6, 4)]\n",
    "  \n",
    "  #print(\"estimated states \" + str(N * N * (3 ** R)), file = f)\n",
    "  #plot_board(obstacles, [], None, N)\n",
    "  return sorted(list(obstacles))\n",
    "obstacles = generate_rocks(N, R)\n",
    "\n",
    "def in_bound(obstacle, lx, ly, rx, ry, file = sys.stdout):\n",
    "  x, y = obstacle[0], obstacle[1]\n",
    "  return lx <= x <= rx and ly <= y <= ry\n",
    "\n",
    "def preamble(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  print(\"pomdp\", file = f)\n",
    "  print(\"observables\", file = f)\n",
    "  observables = [\"started\"]\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    observables.append(\"r{}taken\".format(i))\n",
    "  observables.append(\"done\")\n",
    "  print(\", \".join(observables), file = f)\n",
    "  print(\"endobservables\", file = f)\n",
    "\n",
    "def grid(, file = sys.stdout):\n",
    "  print(\"const int N;\", file = f)\n",
    "  print(\"const int xMAX = N-1;\", file = f)\n",
    "  print(\"const int yMAX = N-1;\", file = f)\n",
    "  print(\"const int xMIN = 0;\", file = f)\n",
    "  print(\"const int yMIN = 0;\", file = f)\n",
    "  print(\"const double slippery = 0.1;\", file = f)\n",
    "  print(\"// How likely is a rock a good rock\", file = f)\n",
    "  print(\"const double goodrock = 0.5;\", file = f)\n",
    "\n",
    "def primary_grid(lx, ly, rx, ry, file = sys.stdout):\n",
    "  print(\"const int primaryMinX = {};\".format(lx), file = f)\n",
    "  print(\"const int primaryMinY = {};\".format(ly), file = f)\n",
    "  print(\"const int primaryMaxX = {};\".format(rx), file = f)\n",
    "  print(\"const int primaryMaxY = {};\".format(ry), file = f)\n",
    "  print(\"const int borderSize = 2;\", file = f)\n",
    "  print(\"const int areaMinX = max(primaryMinX - borderSize, xMIN);\", file = f)\n",
    "  print(\"const int areaMinY = max(primaryMinY - borderSize, yMIN);\", file = f)\n",
    "  print(\"const int areaMaxX = min(primaryMaxX + borderSize, xMAX);\", file = f)\n",
    "  print(\"const int areaMaxY = min(primaryMaxY + borderSize, yMAX);\", file = f)\n",
    "def rock_positions(obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  for i, (x, y) in enumerate(obstacles):\n",
    "    if not in_bound((x, y), lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"const r{}x = {};\".format(i + 1, x), file = f)\n",
    "    print(\"const r{}y = {};\".format(i + 1, y), file = f)\n",
    "def constants(obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  grid()\n",
    "  primary_grid(lx, ly, rx, ry)\n",
    "  rock_positions(obstacles, lx, ly, rx, ry)\n",
    "\n",
    "constants(obstacles, 0, 0, N -1 , N -1)\n",
    "\n",
    "def formula_finish(is_main, file = sys.stdout):\n",
    "  print(\"// We are done when we reach max x location\", file = f)\n",
    "  if is_main:\n",
    "    print(\"formula finish = started & x = xMAX;\", file = f)\n",
    "  else:\n",
    "    string = \"formula finish = started & (!bad) & (x = xMAX | \";\n",
    "    out_primary_bound = \"x = primaryMinX - 1 | x = primaryMinX - 2| y = primaryMinY - 1 | y = primaryMinY - 2 | \"\n",
    "    out_primary_bound += \"x = primaryMaxX + 1 | x = primaryMaxX + 2| y = primaryMaxY + 1 | y = primaryMaxY + 2);\"\n",
    "    print(string + out_primary_bound, file = f)\n",
    "\n",
    "def observable_finish(, file = sys.stdout):\n",
    "  print(\"observable \\\"seefinish\\\" = finish;\", file = f)\n",
    "def formula_maxdist(, file = sys.stdout):\n",
    "  print(\"formula maxdist = xMAX-xMIN+yMAX-yMIN;\", file = f)\n",
    "\n",
    "def formula_good(is_main, R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  if not is_main:\n",
    "    print(\"formula good = finish & done;\", file = f)\n",
    "    return\n",
    "  prefix = \"formula good = finish & done & (\"\n",
    "  ending = \");\"\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "  print(prefix, file = f)\n",
    "\n",
    "def formula_dist(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"formula r{}dist = max(r{}x-x,x-r{}x) + max(r{}y-y,y-r{}y);\".format(i, i, i, i, i), file = f)\n",
    "  \n",
    "def formula_bad(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  prefix = \"formula bad = \"\n",
    "  ending  = \";\"\n",
    "  bad = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    bad.append(\"(r{}dist=0 & !r{}qual)\".format(i, i))\n",
    "  if len(bad) > 0:\n",
    "    prefix += \" | \".join(bad) + ending\n",
    "  else:\n",
    "    prefix += \"false\" + ending;\n",
    "  print(prefix, file = f)\n",
    "\n",
    "def observable_at(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"observable \\\"atr{}\\\" = r{}dist <= 0;\".format(i, i), file = f)\n",
    "def observable_near(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"observable \\\"nearr{}\\\" = r{}dist <= 1;\".format(i, i), file = f)\n",
    "\n",
    "def formula_normdist(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"formula normdistr{} = (r{}dist <= 1) ? 1 : 2; // min(1+((r{}dist-1)/maxdist), 1.0)\".format(i, i, i), file = f)\n",
    "\n",
    "def observable_good_bad(, file = sys.stdout):\n",
    "  print(\"observable \\\"seebad\\\" = bad;\", file = f)\n",
    "  print(\"observable \\\"seegood\\\" = good;\", file = f)\n",
    "\n",
    "def formula_observable(R, is_main, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  formula_finish(is_main)\n",
    "  observable_finish()\n",
    "  formula_maxdist()\n",
    "  formula_good(is_main, R, obstacles, lx, ly, rx, ry)\n",
    "  formula_dist(R, obstacles, lx, ly, rx, ry)\n",
    "  formula_bad(R, obstacles, lx, ly, rx, ry)\n",
    "  formula_normdist(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_at(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_near(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_good_bad()\n",
    "formula_observable(R, False, obstacles, 0, 0, 7, 7)\n",
    "\n",
    "def master(, file = sys.stdout):\n",
    "  print(\"module master\", file = f)\n",
    "  print(\"started : bool init false;\", file = f)\n",
    "  print(\"done : bool init false;\", file = f)\n",
    "  print(\"\", file = f)\n",
    "  print(\"[placement] !started -> (started\\'=true);\", file = f)\n",
    "  print(\"[north] started & !done -> true;\", file = f)\n",
    "  print(\"[south] started  & !done -> true;\", file = f)\n",
    "  print(\"[east] started  & !done-> true;\", file = f)\n",
    "  print(\"[west] started & !done -> true;\", file = f)\n",
    "  print(\"[finish] finish | done -> (done\\'=true);\", file = f)\n",
    "  print(\"endmodule\", file = f)\n",
    "def robot(, file = sys.stdout):\n",
    "  print(\"module robot\", file = f)\n",
    "  print(\"x : [areaMinX..areaMaxX] init primaryMinX;\", file = f)\n",
    "  print(\"y : [areaMinY..areaMaxX] init primaryMinY;\", file = f)\n",
    "  print(\"\", file = f)\n",
    "  print(\"[west] true -> (1-slippery): (x\\'=max(x-1,areaMinX)) + slippery: (x\\'=max(x-2,areaMinX));\", file = f)\n",
    "  print(\"[east] true -> (1-slippery): (x\\'=min(x+1,areaMaxX)) + slippery: (x\\'=min(x+2,areaMaxX));\", file = f)\n",
    "  print(\"[south]  true -> (1-slippery): (y\\'=min(y+1,areaMaxY)) + slippery: (y\\'=min(y+2,areaMaxY));\", file = f)\n",
    "  print(\"[north]  true -> (1-slippery): (y\\'=max(y-1,areaMinY)) + slippery: (y\\'=max(y-2,areaMinY));\", file = f)\n",
    "  print(\"endmodule\", file = f)\n",
    "\n",
    "def one_rock(k, file = sys.stdout):\n",
    "  rk = \"r\" + str(k)\n",
    "  print(\"module rock1\".replace(\"1\", str(k)), file = f)\n",
    "  print(\"r1qual : bool init false;\".replace(\"r1\", rk), file = f)\n",
    "  print(\"r1taken : bool init false;\".replace(\"r1\", rk), file = f)\n",
    "  print(\"r1lastobs : bool init false;\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);\".replace(\"r1\", rk), file = f)\n",
    "  print(\"\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[r1sample] r1dist = 0 & started & !done & !bad & !finish & !r1taken-> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[r1sample] r1dist = 0 & started & !done & !bad & !finish & r1taken -> true;\".replace(\"r1\", rk), file = f)\n",
    "  print(\"\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[north] true -> (r1lastobs'=false);\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[south] true -> (r1lastobs'=false);\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[east] true -> (r1lastobs'=false);\".replace(\"r1\", rk), file = f)\n",
    "  print(\"[west] true -> (r1lastobs'=false);\".replace(\"r1\", rk), file = f)\n",
    "  print(\"endmodule\".replace(\"r1\", rk), file = f)\n",
    "def rocks(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    one_rock(i)\n",
    "\n",
    "def reward_cost(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  reward(R, obstacles, lx, ly, rx, ry)\n",
    "  cost(R, obstacles, lx, ly, rx, ry)\n",
    "\n",
    "def reward(R, obstacles, lx, ly, rx, ry, finishGood = 100, finish = 20, file = sys.stdout):\n",
    "  print(\"rewards \\\"rew\\\"\", file = f)\n",
    "  sampleGood = 100\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"[r{}sample] r{}qual & !r{}taken : {};\".format(i, i, i, sampleGood), file = f)\n",
    "  \n",
    "  prefix = \"[finish] (\"\n",
    "  ending = \"): {};\".format(finishGood) ;\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  if len(qual) > 0:\n",
    "    prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "    print(prefix, file = f)\n",
    "\n",
    "  print(\"[finish] true: {};\".format(finish), file = f)\n",
    "  print(\"endrewards\", file = f)\n",
    "\n",
    "def cost(R, obstacles, lx, ly, rx, ry, finishBad = 100, bad = 20, file = sys.stdout):\n",
    "  \n",
    "  print(\"rewards \\\"cos\\\"\", file = f)\n",
    "  print(\"//[r1sample] !r1qual & !r1taken : 10; // no need; cause it won\\'t r1sample is not enabled if !r1qual\", file = f)\n",
    "  print(\"//[r2sample] !r2qual & !r1taken: 10; // no need; cause it won\\'t r1sample is not enabled if !r1qual\", file = f)\n",
    "  print(\"//[r1sample] r1taken : 20;\", file = f)\n",
    "  print(\"//[r2sample] r2taken : 20;\", file = f)\n",
    "  finishBad = 100\n",
    "  prefix = \"[finish] !(\"\n",
    "  ending = \"): {};\".format(finishBad) ;\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  if len(qual) > 0:\n",
    "    prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "    print(prefix, file = f)\n",
    "  \n",
    "\n",
    "  print(\"bad:{};\".format(20), file = f)\n",
    "  print(\"[east] true: 1;\", file = f)\n",
    "  print(\"[west] true: 1;\", file = f)\n",
    "  print(\"[north] true: 1;\", file = f)\n",
    "  print(\"[south] true: 1;\", file = f)\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"[r{}sense] true: 1;\".format(i), file = f)\n",
    "    \n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    print(\"[r{}sample] true: 1;\".format(i), file = f)\n",
    "  print(\"endrewards\", file = f)\n",
    "def cost_2(, file = sys.stdout):\n",
    "  print(\"rewards \\\"cost\\\"\", file = f)\n",
    "  print(\"[r1sense] true : 1;\", file = f)\n",
    "  print(\"[r1sample] !r1qual : 20;\", file = f)\n",
    "  print(\"[r2sense] true : 1;\", file = f)\n",
    "  print(\"[r2sample] !r2qual : 20;\", file = f)\n",
    "  print(\"//[r3sense] true : 1;\", file = f)\n",
    "  print(\"//[r3sample] !r3qual : 20;\", file = f)\n",
    "  print(\"[north] true : 1;\", file = f)\n",
    "  print(\"[south] true : 1;\", file = f)\n",
    "  print(\"[west] true : 1;\", file = f)\n",
    "  print(\"[east] true : 1;\", file = f)\n",
    "  print(\"[finish] true : (!r1taken & r1qual ? 30 : 0) + (!r2taken & r2qual ? 30 : 0) ;//+ (!r3taken & r3qual ? 30 : 0) ;\", file = f)\n",
    "  print(\"endrewards\", file = f)\n",
    "\n",
    "def labels(R, obstacles, lx, ly, rx, ry, file = sys.stdout):\n",
    "  print(\"label \\\"notbad\\\" = !bad;\", file = f)\n",
    "  print(\"label \\\"goal\\\" = good;\", file = f)\n",
    "  prefix = \"label \\\"rockposition\\\" = \"\n",
    "  ending = \";\"\n",
    "  position = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    position.append(\"(!r{}taken & r{}x = x & r{}y = y)\".format(i, i, i))\n",
    "  #if len(position) > 0:\n",
    "  #  print(prefix + \" | \".join(position) + ending, file = f)\n",
    "\n",
    "def generate_file(N, R, is_main, lx, ly, rx, ry, file = sys.stdout):\n",
    "  obstacles = generate_rocks(N, R)\n",
    "  preamble(R, obstacles, lx, ly, rx, ry)\n",
    "  constants(obstacles, lx, ly, rx, ry)\n",
    "  formula_observable(R, is_main, obstacles, lx, ly, rx, ry)\n",
    "  master()\n",
    "  robot()\n",
    "  rocks(R, obstacles, lx, ly, rx, ry)\n",
    "  labels(R, obstacles, lx, ly, rx, ry)\n",
    "  reward_cost(R, obstacles, lx, ly, rx, ry)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
