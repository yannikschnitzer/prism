{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "id": "LZocXuq41yvR"
   },
   "outputs": [],
   "source": [
    "def plot_board(obstacle, beliefState, agent, N):\n",
    "\n",
    "  from matplotlib import pyplot as plt\n",
    "  fig, ax = plt.subplots(figsize = (N,N))\n",
    "  ax.xaxis.set_ticks_position('top')   #将X坐标轴移到上面\n",
    "  ax.invert_yaxis()  \n",
    "  #\n",
    "  x = [i for i in range(N)]\n",
    "  y = [i for i in range(N)]\n",
    "  plt.xlim((0,N))\n",
    "  #plt.ylim((0,N))\n",
    "  ax.set_ylim(bottom=N, top=0)  # 此处将原点设置为左上角  \n",
    "  plt.xticks([0.5 + i for i in range(N )], labels = [str(i) for i in range(N)])\n",
    "  plt.yticks([0.5 + i for i in range(N)], labels = [str(i) for i in range(N)])\n",
    "  plt.xlabel('X Axis')\n",
    "  plt.ylabel('Y Axis')\n",
    "  width = 1\n",
    "  height =1 \n",
    "\n",
    "  for left, bottom in obstacle:\n",
    "    rect = plt.Rectangle((left, bottom), width, height, facecolor=\"red\", alpha = 1)\n",
    "    ax.add_patch(rect)\n",
    "\n",
    "  for left, bottom in beliefState:\n",
    "    rect = plt.Rectangle((left, bottom), width, height, facecolor=\"blue\", alpha = 0.5)\n",
    "    ax.add_patch(rect)\n",
    "\n",
    "  #plt.scatter(agent[0] + 0.5, agent[1] +0.5)\n",
    "  for i in range(N):\n",
    "    plt.hlines(i, 0, N , alpha = 0.5)\n",
    "    plt.vlines(i, 0, N , alpha = 0.5)\n",
    "  plt.grid(False)\n",
    "  plt.show()\n",
    "\n",
    "\n",
    "def move(belief, action):\n",
    "  result = set()\n",
    "  for x, y in belief:\n",
    "    for slip in [1, 2]:\n",
    "      if action == \"w\":\n",
    "        nx, ny = max(0, x - slip) , y\n",
    "      if action == 'e':\n",
    "        nx, ny = min(N - 1, x + slip), y\n",
    "      if action == 'n':\n",
    "        nx, ny = x, max(0, y - slip)\n",
    "      if action == 's':\n",
    "        nx, ny = x, min(N - 1, y + slip)\n",
    "      result.add((nx, ny))\n",
    "  return list(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "def log_print(string, file = sys.stdout):\n",
    "    print(string, file = file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "id": "-TVDCpqmffGS"
   },
   "outputs": [],
   "source": [
    "N = 2; R = 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "id": "KrKSio0_-IXo"
   },
   "outputs": [],
   "source": [
    "def generate_rocks(N, R):\n",
    "  obstacles = set()\n",
    "  import random\n",
    "  random.seed(N)\n",
    "  while len(obstacles) < R:\n",
    "    obstacle = (random.randint(0, N - 1), random.randint(0, N - 1))\n",
    "    if obstacle == (0, 0):\n",
    "      continue\n",
    "    obstacles.add(obstacle)\n",
    "  if N == 7:\n",
    "    obstacles = [(1, 1), (1, 2), (2, 1), (3, 3), (3, 5), (4, 0), (4, 1), (6, 4)]\n",
    "  \n",
    "  #log_print(\"estimated states \" + str(N * N * (3 ** R)))\n",
    "  #plot_board(obstacles, [], None, N)\n",
    "  return sorted(list(obstacles))\n",
    "obstacles = generate_rocks(N, R)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "id": "KppVWBQAS1x6"
   },
   "outputs": [],
   "source": [
    "def in_bound(obstacle, lx, ly, rx, ry):\n",
    "  x, y = obstacle[0], obstacle[1]\n",
    "  return lx <= x <= rx and ly <= y <= ry\n",
    "\n",
    "def preamble(R, obstacles, lx, ly, rx, ry):\n",
    "  log_print(\"pomdp\")\n",
    "  log_print(\"observables\")\n",
    "  observables = [\"started\"]\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    observables.append(\"r{}taken\".format(i))\n",
    "  observables.append(\"done\")\n",
    "  log_print(\", \".join(observables))\n",
    "  log_print(\"endobservables\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "3fNszRT3BQJM",
    "outputId": "078a4c47-d9df-4e68-dd67-da5b9585fc95"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "const int N;\n",
      "const int xMAX = N-1;\n",
      "const int yMAX = N-1;\n",
      "const int xMIN = 0;\n",
      "const int yMIN = 0;\n",
      "const double slippery = 0.1;\n",
      "// How likely is a rock a good rock\n",
      "const double goodrock = 0.5;\n",
      "const int primaryMinX = 0;\n",
      "const int primaryMinY = 0;\n",
      "const int primaryMaxX = 1;\n",
      "const int primaryMaxY = 1;\n",
      "const int pad = 2;\n",
      "const int areaMinX = max(primaryMinX - pad, xMIN);\n",
      "const int areaMinY = max(primaryMinY - pad, yMIN);\n",
      "const int areaMaxX = min(primaryMaxX + pad, xMAX);\n",
      "const int areaMaxY = min(primaryMaxY + pad, yMAX);\n",
      "const r1x = 0;\n",
      "const r1y = 1;\n",
      "const r2x = 1;\n",
      "const r2y = 0;\n"
     ]
    }
   ],
   "source": [
    "def grid():\n",
    "  log_print(\"const int N;\")\n",
    "  log_print(\"const int xMAX = N-1;\")\n",
    "  log_print(\"const int yMAX = N-1;\")\n",
    "  log_print(\"const int xMIN = 0;\")\n",
    "  log_print(\"const int yMIN = 0;\")\n",
    "  log_print(\"const double slippery = 0.1;\")\n",
    "  log_print(\"// How likely is a rock a good rock\")\n",
    "  log_print(\"const double goodrock = 0.5;\")\n",
    "\n",
    "def primary_grid(lx, ly, rx, ry):\n",
    "  log_print(\"const int primaryMinX = {};\".format(lx))\n",
    "  log_print(\"const int primaryMinY = {};\".format(ly))\n",
    "  log_print(\"const int primaryMaxX = {};\".format(rx))\n",
    "  log_print(\"const int primaryMaxY = {};\".format(ry))\n",
    "  log_print(\"const int pad = 2;\")\n",
    "  log_print(\"const int areaMinX = max(primaryMinX - pad, xMIN);\")\n",
    "  log_print(\"const int areaMinY = max(primaryMinY - pad, yMIN);\")\n",
    "  log_print(\"const int areaMaxX = min(primaryMaxX + pad, xMAX);\")\n",
    "  log_print(\"const int areaMaxY = min(primaryMaxY + pad, yMAX);\")\n",
    "def rock_positions(obstacles, lx, ly, rx, ry):\n",
    "  for i, (x, y) in enumerate(obstacles):\n",
    "    if not in_bound((x, y), lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"const r{}x = {};\".format(i + 1, x))\n",
    "    log_print(\"const r{}y = {};\".format(i + 1, y))\n",
    "def constants(obstacles, lx, ly, rx, ry):\n",
    "  grid()\n",
    "  primary_grid(lx, ly, rx, ry)\n",
    "  rock_positions(obstacles, lx, ly, rx, ry)\n",
    "\n",
    "constants(obstacles, 0, 0, N -1 , N -1)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "FIBskBYxB6m5",
    "outputId": "2366bfbe-83e0-4d03-bab7-893385dbbf75"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "// We are done when we reach max x location\n",
      "formula finish = started & (!bad) & (x = xMAX | x = primaryMinX - 1 | x = primaryMinX - 2| y = primaryMinY - 1 | y = primaryMinY - 2 | x = primaryMaxX + 1 | x = primaryMaxX + 2| y = primaryMaxY + 1 | y = primaryMaxY + 2);\n",
      "observable \"seefinish\" = finish;\n",
      "formula maxdist = xMAX-xMIN+yMAX-yMIN;\n",
      "formula good = finish & done;\n",
      "formula r1dist = max(r1x-x,x-r1x) + max(r1y-y,y-r1y);\n",
      "formula r2dist = max(r2x-x,x-r2x) + max(r2y-y,y-r2y);\n",
      "formula bad = (r1dist=0 & !r1qual) | (r2dist=0 & !r2qual);\n",
      "formula normdistr1 = (r1dist <= 1) ? 1 : 2; // min(1+((r1dist-1)/maxdist), 1.0)\n",
      "formula normdistr2 = (r2dist <= 1) ? 1 : 2; // min(1+((r2dist-1)/maxdist), 1.0)\n",
      "observable \"atr1\" = r1dist <= 0;\n",
      "observable \"atr2\" = r2dist <= 0;\n",
      "observable \"nearr1\" = r1dist <= 1;\n",
      "observable \"nearr2\" = r2dist <= 1;\n",
      "observable \"seebad\" = bad;\n",
      "observable \"seegood\" = good;\n"
     ]
    }
   ],
   "source": [
    "def formula_finish(is_main):\n",
    "  log_print(\"// We are done when we reach max x location\")\n",
    "  if is_main:\n",
    "    log_print(\"formula finish = started & x = xMAX;\")\n",
    "  else:\n",
    "    string = \"formula finish = started & (!bad) & (x = xMAX | \";\n",
    "    out_primary_bound = \"x = primaryMinX - 1 | x = primaryMinX - 2| y = primaryMinY - 1 | y = primaryMinY - 2 | \"\n",
    "    out_primary_bound += \"x = primaryMaxX + 1 | x = primaryMaxX + 2| y = primaryMaxY + 1 | y = primaryMaxY + 2);\"\n",
    "    log_print(string + out_primary_bound)\n",
    "\n",
    "def observable_finish():\n",
    "  log_print(\"observable \\\"seefinish\\\" = finish;\")\n",
    "def formula_maxdist():\n",
    "  log_print(\"formula maxdist = xMAX-xMIN+yMAX-yMIN;\")\n",
    "\n",
    "def formula_good(is_main, R, obstacles, lx, ly, rx, ry):\n",
    "  if not is_main:\n",
    "    log_print(\"formula good = finish & done;\")\n",
    "    return\n",
    "  prefix = \"formula good = finish & done & (\"\n",
    "  ending = \");\"\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "def formula_dist(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"formula r{}dist = max(r{}x-x,x-r{}x) + max(r{}y-y,y-r{}y);\".format(i, i, i, i, i))\n",
    "  \n",
    "def formula_bad(R, obstacles, lx, ly, rx, ry):\n",
    "  prefix = \"formula bad = \"\n",
    "  ending  = \";\"\n",
    "  bad = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    bad.append(\"(r{}dist=0 & !r{}qual)\".format(i, i))\n",
    "  prefix += \" | \".join(bad) + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "def observable_at(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"observable \\\"atr{}\\\" = r{}dist <= 0;\".format(i, i))\n",
    "def observable_near(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"observable \\\"nearr{}\\\" = r{}dist <= 1;\".format(i, i))\n",
    "\n",
    "def formula_normdist(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"formula normdistr{} = (r{}dist <= 1) ? 1 : 2; // min(1+((r{}dist-1)/maxdist), 1.0)\".format(i, i, i))\n",
    "\n",
    "def observable_good_bad():\n",
    "  log_print(\"observable \\\"seebad\\\" = bad;\")\n",
    "  log_print(\"observable \\\"seegood\\\" = good;\")\n",
    "\n",
    "def formula_observable(R, is_main, obstacles, lx, ly, rx, ry):\n",
    "  formula_finish(is_main)\n",
    "  observable_finish()\n",
    "  formula_maxdist()\n",
    "  formula_good(is_main, R, obstacles, lx, ly, rx, ry)\n",
    "  formula_dist(R, obstacles, lx, ly, rx, ry)\n",
    "  formula_bad(R, obstacles, lx, ly, rx, ry)\n",
    "  formula_normdist(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_at(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_near(R, obstacles, lx, ly, rx, ry)\n",
    "  observable_good_bad()\n",
    "formula_observable(R, False, obstacles, 0, 0, 7, 7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "5DCwt69cNAT4",
    "outputId": "141d7454-6712-4212-9893-a8da0d24d0e1"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "module master\n",
      "started : bool init false;\n",
      "done : bool init false;\n",
      "\n",
      "[placement] !started -> (started'=true);\n",
      "[north] started & !done -> true;\n",
      "[south] started  & !done -> true;\n",
      "[east] started  & !done-> true;\n",
      "[west] started & !done -> true;\n",
      "[finish] finish | done -> (done'=true);\n",
      "endmodule\n",
      "module robot\n",
      "x : [areaMinX..areaMaxX] init primaryMinX;\n",
      "y : [areaMinY..areaMaxX] init primaryMaxX;\n",
      "\n",
      "[west] true -> (1-slippery): (x'=max(x-1,areaMinX)) + slippery: (x'=max(x-2,areaMinX));\n",
      "[east] true -> (1-slippery): (x'=min(x+1,areaMaxX)) + slippery: (x'=min(x+2,areaMaxX));\n",
      "[south]  true -> (1-slippery): (y'=min(y+1,areaMaxY)) + slippery: (y'=min(y+2,areaMaxY));\n",
      "[north]  true -> (1-slippery): (y'=max(y-1,areaMinY)) + slippery: (y'=max(y-2,areaMinY));\n",
      "endmodule\n"
     ]
    }
   ],
   "source": [
    "def master():\n",
    "  log_print(\"module master\")\n",
    "  log_print(\"started : bool init false;\")\n",
    "  log_print(\"done : bool init false;\")\n",
    "  log_print(\"\")\n",
    "  log_print(\"[placement] !started -> (started\\'=true);\")\n",
    "  log_print(\"[north] started & !done -> true;\")\n",
    "  log_print(\"[south] started  & !done -> true;\")\n",
    "  log_print(\"[east] started  & !done-> true;\")\n",
    "  log_print(\"[west] started & !done -> true;\")\n",
    "  log_print(\"[finish] finish | done -> (done\\'=true);\")\n",
    "  log_print(\"endmodule\")\n",
    "def robot():\n",
    "  log_print(\"module robot\")\n",
    "  log_print(\"x : [areaMinX..areaMaxX] init primaryMinX;\")\n",
    "  log_print(\"y : [areaMinY..areaMaxX] init primaryMaxX;\")\n",
    "  log_print(\"\")\n",
    "  log_print(\"[west] true -> (1-slippery): (x\\'=max(x-1,areaMinX)) + slippery: (x\\'=max(x-2,areaMinX));\")\n",
    "  log_print(\"[east] true -> (1-slippery): (x\\'=min(x+1,areaMaxX)) + slippery: (x\\'=min(x+2,areaMaxX));\")\n",
    "  log_print(\"[south]  true -> (1-slippery): (y\\'=min(y+1,areaMaxY)) + slippery: (y\\'=min(y+2,areaMaxY));\")\n",
    "  log_print(\"[north]  true -> (1-slippery): (y\\'=max(y-1,areaMinY)) + slippery: (y\\'=max(y-2,areaMinY));\")\n",
    "  log_print(\"endmodule\")\n",
    "master()\n",
    "robot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/"
    },
    "id": "6h9KBsM_OHVX",
    "outputId": "e3f8e932-139b-4778-9f32-95aa4085d794"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "module rock1\n",
      "r1qual : bool init false;\n",
      "r1taken : bool init false;\n",
      "r1lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);\n",
      "\n",
      "[r1sample] r1dist = 0 & started & !done & !bad & !finish & !r1taken-> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));\n",
      "[r1sample] r1dist = 0 & started & !done & !bad & !finish & r1taken -> true;\n",
      "\n",
      "[r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);\n",
      "[north] true -> (r1lastobs'=false);\n",
      "[south] true -> (r1lastobs'=false);\n",
      "[east] true -> (r1lastobs'=false);\n",
      "[west] true -> (r1lastobs'=false);\n",
      "endmodule\n",
      "module rock2\n",
      "r2qual : bool init false;\n",
      "r2taken : bool init false;\n",
      "r2lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r2qual'=true) + (1-goodrock) : (r2qual'=false);\n",
      "\n",
      "[r2sample] r2dist = 0 & started & !done & !bad & !finish & !r2taken-> 1:(r2taken'=(x = r2x & y = r2y & !r2taken));\n",
      "[r2sample] r2dist = 0 & started & !done & !bad & !finish & r2taken -> true;\n",
      "\n",
      "[r2sense] started & !r2taken & !done & !bad & !finish -> (1/normdistr2): (r2lastobs'=r2qual) +  (1-(1/normdistr2)): (r2lastobs'=!r2qual);\n",
      "[north] true -> (r2lastobs'=false);\n",
      "[south] true -> (r2lastobs'=false);\n",
      "[east] true -> (r2lastobs'=false);\n",
      "[west] true -> (r2lastobs'=false);\n",
      "endmodule\n"
     ]
    }
   ],
   "source": [
    "def one_rock(k):\n",
    "  rk = \"r\" + str(k)\n",
    "  log_print(\"module rock1\".replace(\"1\", str(k)))\n",
    "  log_print(\"r1qual : bool init false;\".replace(\"r1\", rk))\n",
    "  log_print(\"r1taken : bool init false;\".replace(\"r1\", rk))\n",
    "  log_print(\"r1lastobs : bool init false;\".replace(\"r1\", rk))\n",
    "  log_print(\"[placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"\".replace(\"r1\", rk))\n",
    "  log_print(\"[r1sample] r1dist = 0 & started & !done & !bad & !finish & !r1taken-> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));\".replace(\"r1\", rk))\n",
    "  log_print(\"[r1sample] r1dist = 0 & started & !done & !bad & !finish & r1taken -> true;\".replace(\"r1\", rk))\n",
    "  log_print(\"\".replace(\"r1\", rk))\n",
    "  log_print(\"[r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);\".replace(\"r1\", rk))\n",
    "  log_print(\"[north] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"[south] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"[east] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"[west] true -> (r1lastobs'=false);\".replace(\"r1\", rk))\n",
    "  log_print(\"endmodule\".replace(\"r1\", rk))\n",
    "def rocks(R, obstacles, lx, ly, rx, ry):\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    one_rock(i)\n",
    "rocks(R, obstacles, 0, 0, 7, 7)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "id": "EtwQO_MfP5Kw"
   },
   "outputs": [],
   "source": [
    "def reward_cost(R, obstacles, lx, ly, rx, ry):\n",
    "  reward(R, obstacles, lx, ly, rx, ry)\n",
    "  cost(R, obstacles, lx, ly, rx, ry)\n",
    "\n",
    "def reward(R, obstacles, lx, ly, rx, ry, finishGood = 100, finish = 20):\n",
    "  log_print(\"rewards \\\"rew\\\"\")\n",
    "  sampleGood = 100\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"[r{}sample] r{}qual & !r{}taken : {};\".format(i, i, i, sampleGood))\n",
    "  \n",
    "  prefix = \"[finish] (\"\n",
    "  ending = \"): {};\".format(finishGood) ;\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "  log_print(\"[finish] true: {};\".format(finish))\n",
    "  log_print(\"endrewards\")\n",
    "\n",
    "def cost(R, obstacles, lx, ly, rx, ry, finishBad = 100, bad = 20):\n",
    "  \n",
    "  log_print(\"rewards \\\"cos\\\"\")\n",
    "  log_print(\"//[r1sample] !r1qual & !r1taken : 10; // no need; cause it won\\'t r1sample is not enabled if !r1qual\")\n",
    "  log_print(\"//[r2sample] !r2qual & !r1taken: 10; // no need; cause it won\\'t r1sample is not enabled if !r1qual\")\n",
    "  log_print(\"//[r1sample] r1taken : 20;\")\n",
    "  log_print(\"//[r2sample] r2taken : 20;\")\n",
    "  finishBad = 100\n",
    "  prefix = \"[finish] !(\"\n",
    "  ending = \"): {};\".format(finishBad) ;\n",
    "  qual = []\n",
    "  taken = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    qual.append(\"!r{}qual\".format(i))\n",
    "    taken.append(\"r{}taken\".format(i))\n",
    "  prefix += \"(\" + \" & \".join(qual) + \") | (\" + \" | \".join(taken) + \")\" + ending\n",
    "  log_print(prefix)\n",
    "\n",
    "  log_print(\"bad:{};\".format(20))\n",
    "  log_print(\"[east] true: 1;\")\n",
    "  log_print(\"[west] true: 1;\")\n",
    "  log_print(\"[north] true: 1;\")\n",
    "  log_print(\"[south] true: 1;\")\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"[r{}sense] true: 1;\".format(i))\n",
    "    \n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    log_print(\"[r{}sample] true: 1;\".format(i))\n",
    "  log_print(\"endrewards\")\n",
    "\n",
    "  log_print(\"rewards \\\"cost\\\"\")\n",
    "  log_print(\"[r1sense] true : 1;\")\n",
    "  log_print(\"[r1sample] !r1qual : 20;\")\n",
    "  log_print(\"[r2sense] true : 1;\")\n",
    "  log_print(\"[r2sample] !r2qual : 20;\")\n",
    "  log_print(\"//[r3sense] true : 1;\")\n",
    "  log_print(\"//[r3sample] !r3qual : 20;\")\n",
    "  log_print(\"[north] true : 1;\")\n",
    "  log_print(\"[south] true : 1;\")\n",
    "  log_print(\"[west] true : 1;\")\n",
    "  log_print(\"[east] true : 1;\")\n",
    "  log_print(\"[finish] true : (!r1taken & r1qual ? 30 : 0) + (!r2taken & r2qual ? 30 : 0) ;//+ (!r3taken & r3qual ? 30 : 0) ;\")\n",
    "  log_print(\"endrewards\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "id": "BG_-bFfSWKrf"
   },
   "outputs": [],
   "source": [
    "def labels(R, obstacles, lx, ly, rx, ry):\n",
    "  log_print(\"label \\\"notbad\\\" = !bad;\")\n",
    "  log_print(\"label \\\"goal\\\" = good;\")\n",
    "  prefix = \"label \\\"rockposition\\\" = \"\n",
    "  ending = \";\"\n",
    "  position = []\n",
    "  for i in range(1, R + 1):\n",
    "    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):\n",
    "      continue\n",
    "    position.append(\"(!r{}taken & r{}x = x & r{}y = y)\".format(i, i, i))\n",
    "  log_print(prefix + \" | \".join(position) + ending)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "id": "9dqRGT3KVF7P"
   },
   "outputs": [],
   "source": [
    "def generate_file(N, R, is_main, lx, ly, rx, ry):\n",
    "  obstacles = generate_rocks(N, R)\n",
    "  preamble(R, obstacles, lx, ly, rx, ry)\n",
    "  constants(obstacles, lx, ly, rx, ry)\n",
    "  formula_observable(R, is_main, obstacles, lx, ly, rx, ry)\n",
    "  master()\n",
    "  robot()\n",
    "  rocks(R, obstacles, lx, ly, rx, ry)\n",
    "  labels(R, obstacles, lx, ly, rx, ry)\n",
    "  reward_cost(R, obstacles, lx, ly, rx, ry)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "id": "DbddqkCnnAGy"
   },
   "outputs": [],
   "source": [
    "N = 8\n",
    "R = 4\n",
    "obstacles = generate_rocks(N, R)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "id": "UiwK77kqO4Xq"
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "pomdp\n",
      "observables\n",
      "started, r1taken, r2taken, r3taken, r4taken, done\n",
      "endobservables\n",
      "const int N;\n",
      "const int xMAX = N-1;\n",
      "const int yMAX = N-1;\n",
      "const int xMIN = 0;\n",
      "const int yMIN = 0;\n",
      "const double slippery = 0.1;\n",
      "// How likely is a rock a good rock\n",
      "const double goodrock = 0.5;\n",
      "const int primaryMinX = 0;\n",
      "const int primaryMinY = 0;\n",
      "const int primaryMaxX = 7;\n",
      "const int primaryMaxY = 7;\n",
      "const int pad = 2;\n",
      "const int areaMinX = max(primaryMinX - pad, xMIN);\n",
      "const int areaMinY = max(primaryMinY - pad, yMIN);\n",
      "const int areaMaxX = min(primaryMaxX + pad, xMAX);\n",
      "const int areaMaxY = min(primaryMaxY + pad, yMAX);\n",
      "const r1x = 1;\n",
      "const r1y = 2;\n",
      "const r2x = 3;\n",
      "const r2y = 0;\n",
      "const r3x = 3;\n",
      "const r3y = 5;\n",
      "const r4x = 6;\n",
      "const r4y = 2;\n",
      "// We are done when we reach max x location\n",
      "formula finish = started & x = xMAX;\n",
      "observable \"seefinish\" = finish;\n",
      "formula maxdist = xMAX-xMIN+yMAX-yMIN;\n",
      "formula good = finish & done & ((!r1qual & !r2qual & !r3qual & !r4qual) | (r1taken | r2taken | r3taken | r4taken));\n",
      "formula r1dist = max(r1x-x,x-r1x) + max(r1y-y,y-r1y);\n",
      "formula r2dist = max(r2x-x,x-r2x) + max(r2y-y,y-r2y);\n",
      "formula r3dist = max(r3x-x,x-r3x) + max(r3y-y,y-r3y);\n",
      "formula r4dist = max(r4x-x,x-r4x) + max(r4y-y,y-r4y);\n",
      "formula bad = (r1dist=0 & !r1qual) | (r2dist=0 & !r2qual) | (r3dist=0 & !r3qual) | (r4dist=0 & !r4qual);\n",
      "formula normdistr1 = (r1dist <= 1) ? 1 : 2; // min(1+((r1dist-1)/maxdist), 1.0)\n",
      "formula normdistr2 = (r2dist <= 1) ? 1 : 2; // min(1+((r2dist-1)/maxdist), 1.0)\n",
      "formula normdistr3 = (r3dist <= 1) ? 1 : 2; // min(1+((r3dist-1)/maxdist), 1.0)\n",
      "formula normdistr4 = (r4dist <= 1) ? 1 : 2; // min(1+((r4dist-1)/maxdist), 1.0)\n",
      "observable \"atr1\" = r1dist <= 0;\n",
      "observable \"atr2\" = r2dist <= 0;\n",
      "observable \"atr3\" = r3dist <= 0;\n",
      "observable \"atr4\" = r4dist <= 0;\n",
      "observable \"nearr1\" = r1dist <= 1;\n",
      "observable \"nearr2\" = r2dist <= 1;\n",
      "observable \"nearr3\" = r3dist <= 1;\n",
      "observable \"nearr4\" = r4dist <= 1;\n",
      "observable \"seebad\" = bad;\n",
      "observable \"seegood\" = good;\n",
      "module master\n",
      "started : bool init false;\n",
      "done : bool init false;\n",
      "\n",
      "[placement] !started -> (started'=true);\n",
      "[north] started & !done -> true;\n",
      "[south] started  & !done -> true;\n",
      "[east] started  & !done-> true;\n",
      "[west] started & !done -> true;\n",
      "[finish] finish | done -> (done'=true);\n",
      "endmodule\n",
      "module robot\n",
      "x : [areaMinX..areaMaxX] init primaryMinX;\n",
      "y : [areaMinY..areaMaxX] init primaryMaxX;\n",
      "\n",
      "[west] true -> (1-slippery): (x'=max(x-1,areaMinX)) + slippery: (x'=max(x-2,areaMinX));\n",
      "[east] true -> (1-slippery): (x'=min(x+1,areaMaxX)) + slippery: (x'=min(x+2,areaMaxX));\n",
      "[south]  true -> (1-slippery): (y'=min(y+1,areaMaxY)) + slippery: (y'=min(y+2,areaMaxY));\n",
      "[north]  true -> (1-slippery): (y'=max(y-1,areaMinY)) + slippery: (y'=max(y-2,areaMinY));\n",
      "endmodule\n",
      "module rock1\n",
      "r1qual : bool init false;\n",
      "r1taken : bool init false;\n",
      "r1lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);\n",
      "\n",
      "[r1sample] r1dist = 0 & started & !done & !bad & !finish & !r1taken-> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));\n",
      "[r1sample] r1dist = 0 & started & !done & !bad & !finish & r1taken -> true;\n",
      "\n",
      "[r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);\n",
      "[north] true -> (r1lastobs'=false);\n",
      "[south] true -> (r1lastobs'=false);\n",
      "[east] true -> (r1lastobs'=false);\n",
      "[west] true -> (r1lastobs'=false);\n",
      "endmodule\n",
      "module rock2\n",
      "r2qual : bool init false;\n",
      "r2taken : bool init false;\n",
      "r2lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r2qual'=true) + (1-goodrock) : (r2qual'=false);\n",
      "\n",
      "[r2sample] r2dist = 0 & started & !done & !bad & !finish & !r2taken-> 1:(r2taken'=(x = r2x & y = r2y & !r2taken));\n",
      "[r2sample] r2dist = 0 & started & !done & !bad & !finish & r2taken -> true;\n",
      "\n",
      "[r2sense] started & !r2taken & !done & !bad & !finish -> (1/normdistr2): (r2lastobs'=r2qual) +  (1-(1/normdistr2)): (r2lastobs'=!r2qual);\n",
      "[north] true -> (r2lastobs'=false);\n",
      "[south] true -> (r2lastobs'=false);\n",
      "[east] true -> (r2lastobs'=false);\n",
      "[west] true -> (r2lastobs'=false);\n",
      "endmodule\n",
      "module rock3\n",
      "r3qual : bool init false;\n",
      "r3taken : bool init false;\n",
      "r3lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r3qual'=true) + (1-goodrock) : (r3qual'=false);\n",
      "\n",
      "[r3sample] r3dist = 0 & started & !done & !bad & !finish & !r3taken-> 1:(r3taken'=(x = r3x & y = r3y & !r3taken));\n",
      "[r3sample] r3dist = 0 & started & !done & !bad & !finish & r3taken -> true;\n",
      "\n",
      "[r3sense] started & !r3taken & !done & !bad & !finish -> (1/normdistr3): (r3lastobs'=r3qual) +  (1-(1/normdistr3)): (r3lastobs'=!r3qual);\n",
      "[north] true -> (r3lastobs'=false);\n",
      "[south] true -> (r3lastobs'=false);\n",
      "[east] true -> (r3lastobs'=false);\n",
      "[west] true -> (r3lastobs'=false);\n",
      "endmodule\n",
      "module rock4\n",
      "r4qual : bool init false;\n",
      "r4taken : bool init false;\n",
      "r4lastobs : bool init false;\n",
      "[placement] true -> goodrock : (r4qual'=true) + (1-goodrock) : (r4qual'=false);\n",
      "\n",
      "[r4sample] r4dist = 0 & started & !done & !bad & !finish & !r4taken-> 1:(r4taken'=(x = r4x & y = r4y & !r4taken));\n",
      "[r4sample] r4dist = 0 & started & !done & !bad & !finish & r4taken -> true;\n",
      "\n",
      "[r4sense] started & !r4taken & !done & !bad & !finish -> (1/normdistr4): (r4lastobs'=r4qual) +  (1-(1/normdistr4)): (r4lastobs'=!r4qual);\n",
      "[north] true -> (r4lastobs'=false);\n",
      "[south] true -> (r4lastobs'=false);\n",
      "[east] true -> (r4lastobs'=false);\n",
      "[west] true -> (r4lastobs'=false);\n",
      "endmodule\n",
      "label \"notbad\" = !bad;\n",
      "label \"goal\" = good;\n",
      "label \"rockposition\" = (!r1taken & r1x = x & r1y = y) | (!r2taken & r2x = x & r2y = y) | (!r3taken & r3x = x & r3y = y) | (!r4taken & r4x = x & r4y = y);\n",
      "rewards \"rew\"\n",
      "[r1sample] r1qual & !r1taken : 100;\n",
      "[r2sample] r2qual & !r2taken : 100;\n",
      "[r3sample] r3qual & !r3taken : 100;\n",
      "[r4sample] r4qual & !r4taken : 100;\n",
      "[finish] ((!r1qual & !r2qual & !r3qual & !r4qual) | (r1taken | r2taken | r3taken | r4taken)): 100;\n",
      "[finish] true: 20;\n",
      "endrewards\n",
      "rewards \"cos\"\n",
      "//[r1sample] !r1qual & !r1taken : 10; // no need; cause it won't r1sample is not enabled if !r1qual\n",
      "//[r2sample] !r2qual & !r1taken: 10; // no need; cause it won't r1sample is not enabled if !r1qual\n",
      "//[r1sample] r1taken : 20;\n",
      "//[r2sample] r2taken : 20;\n",
      "[finish] !((!r1qual & !r2qual & !r3qual & !r4qual) | (r1taken | r2taken | r3taken | r4taken)): 100;\n",
      "bad:20;\n",
      "[east] true: 1;\n",
      "[west] true: 1;\n",
      "[north] true: 1;\n",
      "[south] true: 1;\n",
      "[r1sense] true: 1;\n",
      "[r2sense] true: 1;\n",
      "[r3sense] true: 1;\n",
      "[r4sense] true: 1;\n",
      "[r1sample] true: 1;\n",
      "[r2sample] true: 1;\n",
      "[r3sample] true: 1;\n",
      "[r4sample] true: 1;\n",
      "endrewards\n",
      "rewards \"cost\"\n",
      "[r1sense] true : 1;\n",
      "[r1sample] !r1qual : 20;\n",
      "[r2sense] true : 1;\n",
      "[r2sample] !r2qual : 20;\n",
      "//[r3sense] true : 1;\n",
      "//[r3sample] !r3qual : 20;\n",
      "[north] true : 1;\n",
      "[south] true : 1;\n",
      "[west] true : 1;\n",
      "[east] true : 1;\n",
      "[finish] true : (!r1taken & r1qual ? 30 : 0) + (!r2taken & r2qual ? 30 : 0) ;//+ (!r3taken & r3qual ? 30 : 0) ;\n",
      "endrewards\n"
     ]
    }
   ],
   "source": [
    "\n",
    "xMIN = yMIN = 0\n",
    "xMAX = yMAX = N - 1\n",
    "generate_file(N, R, True, xMIN, yMIN, xMAX, yMAX)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "u_vrQSUrQIuL"
   },
   "outputs": [],
   "source": [
    "shieldSize = 4\n",
    "shieldSizeX = 4\n",
    "shieldSizeY = 4\n",
    "\n",
    "    \n",
    "for lx in range(0, xMAX, shieldSizeX):\n",
    "  for ly in range(0, yMAX, shieldSizeY):\n",
    "    rx, ry = lx + shieldSizeX - 1, ly + shieldSizeY - 1\n",
    "    if not (lx == 0 and ly == 0):\n",
    "      continue\n",
    "    sys.stdout = open('filedd', w)\n",
    "\n",
    "    generate_file(N, R, False, lx, ly, rx, ry)\n",
    "    sys.stoud.close()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.stdout = open('file2', 'w')\n",
    "print('test')\n",
    "sys.stdout.close()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on built-in function print in module builtins:\n",
      "\n",
      "print(...)\n",
      "    print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n",
      "    \n",
      "    Prints the values to a stream, or to sys.stdout by default.\n",
      "    Optional keyword arguments:\n",
      "    file:  a file-like object (stream); defaults to the current sys.stdout.\n",
      "    sep:   string inserted between values, default a space.\n",
      "    end:   string appended after the last value, default a newline.\n",
      "    flush: whether to forcibly flush the stream.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(print)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 514
    },
    "id": "wcDkWYlSfh1L",
    "outputId": "83d770d0-3ab5-4685-d537-00e72d71bc8b"
   },
   "outputs": [],
   "source": [
    "obstacles = generate_rocks(N, R)\n",
    "log_print(obstacles)\n",
    "plot_board(obstacles, [], None, 8)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "cdU1e5cu1cnv"
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Exception in thread IPythonHistorySavingThread:\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/IPython/core/history.py\", line 779, in writeout_cache\n",
      "    self._writeout_input_cache(conn)\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/IPython/core/history.py\", line 762, in _writeout_input_cache\n",
      "    conn.execute(\"INSERT INTO history VALUES (?, ?, ?, ?)\",\n",
      "sqlite3.IntegrityError: UNIQUE constraint failed: history.session, history.line\n",
      "\n",
      "During handling of the above exception, another exception occurred:\n",
      "\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/IPython/core/history.py\", line 834, in run\n",
      "    self.history_manager.writeout_cache(self.db)\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/decorator.py\", line 232, in fun\n",
      "    return caller(func, *(extras + args), **kw)\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/IPython/core/history.py\", line 60, in only_when_enabled\n",
      "    return f(self, *a, **kw)\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/IPython/core/history.py\", line 782, in writeout_cache\n",
      "    print(\"ERROR! Session/line number was not unique in\",\n",
      "ValueError: I/O operation on closed file.\n",
      "\n",
      "During handling of the above exception, another exception occurred:\n",
      "\n",
      "Traceback (most recent call last):\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/threading.py\", line 973, in _bootstrap_inner\n",
      "    self.run()\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/decorator.py\", line 232, in fun\n",
      "    return caller(func, *(extras + args), **kw)\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/IPython/core/history.py\", line 60, in only_when_enabled\n",
      "    return f(self, *a, **kw)\n",
      "  File \"/Users/shengsheng/opt/anaconda3/lib/python3.9/site-packages/IPython/core/history.py\", line 836, in run\n",
      "    print((\"The history saving thread hit an unexpected error (%s).\"\n",
      "ValueError: I/O operation on closed file.\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import pandas as pd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 200
    },
    "id": "oNWrbXMFH3xU",
    "outputId": "8cdb033b-cea1-41c4-c56d-14dd5e8f4342"
   },
   "outputs": [],
   "source": [
    "plot_board(obstacle, [((2,3))],  agent, N)\n",
    "#plot_board(obstacle, [(2,3),(2,1)],  agent, N)\n",
    "#plot_board(obstacle, [(4,4)],  agent, N)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Ay8FHPMtthhe"
   },
   "outputs": [],
   "source": [
    "obstacle = [(1, 0), (5, 1),  (2, 4), (4, 4), (5,4), (5,5)]\n",
    "belief = [(2, 1), (1, 1),  (1, 3), (3,4)]\n",
    "agent= (2,1)\n",
    "N = 6\n",
    "plot_board(obstacle, belief, agent, N)\n",
    "\n",
    "s, w, e, n = 's', 'w', 'e', 'n'\n",
    "for action in [s, e, e, s, e,  e]:\n",
    "  belief = move(belief, action)\n",
    "  plot_board(obstacle, belief, agent, N)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Zn85QTTVok1R"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "eLFV1WF2juHF"
   },
   "outputs": [],
   "source": [
    "\n",
    "path = \"/content/drive/MyDrive/2021-03-25 MO-POMDP/shielding/\"\n",
    "prism_file = \"Shili todo list - MO-POMDP - Sheet6.csv\"\n",
    "stompy_file = \"Shili todo list - MO-POMDP - Sheet5.csv\"\n",
    "prism = pd.read_csv(path + prism_file)\n",
    "stompy = pd.read_csv(path + stompy_file)\n",
    "stompy = stompy.loc[:, ['s', 'o', 'x', 'y', 'r1qual', 'r1taken', 'r1lastobs', 'r2qual', 'r2taken', 'r2lastobs']]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Qy1sAAGqoIxu"
   },
   "outputs": [],
   "source": [
    "prism.columns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "HZqJPUJuljsP"
   },
   "outputs": [],
   "source": [
    "data = prism\n",
    "feature = \"obs\"\n",
    "for i in range(len(data)):\n",
    "  obs = data.loc[i, feature]\n",
    "  obs_size = len(data.loc[data.loc[:, feature] == obs, :])\n",
    "  data.loc[i, \"obs_size\"] = obs_size\n",
    "\n",
    "data = stompy\n",
    "feature = \"o\"\n",
    "for i in range(len(data)):\n",
    "  obs = data.loc[i, feature]\n",
    "  obs_size = len(data.loc[data.loc[:, feature] == obs, :])\n",
    "  data.loc[i, \"obs_size\"] = obs_size\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "tbzk_wrKkBXW"
   },
   "outputs": [],
   "source": [
    "for i in range(10):\n",
    "  c1 = prism.r1qual == stompy.loc[i, \"r1qual\"]\n",
    "  c2 = prism.r1taken == stompy.loc[i, \"r1taken\"]\n",
    "  c3 = prism.x == stompy.loc[i, \"x\"]\n",
    "  c4 = prism.y == stompy.loc[i, \"y\"]\n",
    "  c5 = prism.obs_size == stompy.loc[i, \"obs_size\"]\n",
    "  c6 = prism.r2qual == stompy.loc[i, \"r2qual\"]\n",
    "  c7 = prism.r2taken == stompy.loc[i, \"r2taken\"]\n",
    "\n",
    "  condition = c1 & c2 & c3 & c4 & c6 & c7\n",
    "  tp = prism.loc[condition, :]\n",
    "\n",
    "  sc1 = stompy.r1qual == stompy.loc[i, \"r1qual\"]\n",
    "  sc2 = stompy.r1taken == stompy.loc[i, \"r1taken\"]\n",
    "  sc3 = stompy.x == stompy.loc[i, \"x\"]\n",
    "  sc4 = stompy.y == stompy.loc[i, \"y\"]\n",
    "  sc5 = stompy.obs_size == stompy.loc[i, \"obs_size\"]\n",
    "  sc6 = stompy.r2qual == stompy.loc[i, \"r2qual\"]\n",
    "  sc7 = stompy.r2taken == stompy.loc[i, \"r2taken\"]\n",
    "  scondition = sc1 & sc2 & sc3 & sc4 & sc5 & sc6 &sc7\n",
    "  stp = stompy.loc[scondition, :]\n",
    "  #c1 = prism.r1qual == stompy.loc[i, \"r1qual\"]\n",
    "  log_print(stompy.loc[i,:])\n",
    "  log_print(tp) \n",
    "  log_print(stp) \n",
    "  log_print(\"++++++++++++++++++++++++++\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "j0AFWI2O55fq"
   },
   "outputs": [],
   "source": [
    "def bitfield(n):\n",
    "  tp =[int(digit) for digit in bin(n)[2:]]\n",
    "  while len(tp)<64:\n",
    "    tp.insert(0,0)\n",
    "  return tp# [2:] to chop off the \"0b\" part "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "F7QIoVp2m-e8"
   },
   "outputs": [],
   "source": [
    "nums = [16167922662260080640,9223372036854775808,18410715276690587648 ]\n",
    "for n in nums:\n",
    "  log_print(bitfield(n))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Q5r8aBFY5-k9"
   },
   "outputs": [],
   "source": [
    "a = [ 13546120693153792]\n",
    "un = []\n",
    "for i in range(len(a)):\n",
    "  startIndex = 0 if (i % 2 ==0) else 64\n",
    "  tp = bitfield(a[i])\n",
    "  un2 = []\n",
    "  for j in range(len(tp)):\n",
    "    if (tp[j]==1):\n",
    "      un2.append(j + startIndex)\n",
    "      un.append(j + startIndex)\n",
    "  log_print(un2)\n",
    "un.sort()\n",
    "log_print(un)\n",
    "\n",
    "#[3 13 14 15 28 30 31 36 51 53 59 64 72 73 82 83 ]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "kEHeF4GxnNMe"
   },
   "outputs": [],
   "source": [
    "log_print(bitfield(4608))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "W1uvzP8-m4LP"
   },
   "outputs": [],
   "source": [
    "bucket1 = []\n",
    "bucket2 = []\n",
    "index = [54, 72, 72, 74, 74, 82, 82, 53, 55, 55, 73, 73, 75, 75, 83, 52, 54] \n",
    "for i in index:\n",
    "  if (i >=64):\n",
    "    bucket2.append(i) \n",
    "  else:\n",
    "    bucket1.append(i)\n",
    "log_print(bucket1)\n",
    "log_print(bucket2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "ot_CFXDAnQkG"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "im8reSETIkDd"
   },
   "outputs": [],
   "source": [
    "\n",
    "un = set()\n",
    "a=[4608, 135195949751336960]\n",
    "for i in a:\n",
    "  un2 = set()\n",
    "  log_print(bitfield(i),  len(bitfield(i)))\n",
    "  tp = bitfield(i)\n",
    "  for j in range(len(tp)):\n",
    "    if (tp[j] == 1):\n",
    "      un.add(j)\n",
    "      un2.add(j)\n",
    "  log_print(un2)\n",
    "un = (list(un))\n",
    "un.sort()\n",
    "log_print(un, len(un))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "pAPZqBYgcXM8"
   },
   "outputs": [],
   "source": [
    "[3 13 14 15 28 30 31 36 51 53 59 64 72 73 82 83 ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "eES9qpMG2FFa"
   },
   "outputs": [],
   "source": [
    "def nextPosition(cur, a):\n",
    "    if a == 'n':\n",
    "      return cur + 10\n",
    "    elif a == 'w':\n",
    "      return cur - 1\n",
    "    elif a == 's':\n",
    "      return cur - 10\n",
    "    elif a =='e':\n",
    "      return cur +1\n",
    "    else:\n",
    "      return -1\n",
    "def inBound(next):\n",
    "    if (next<0):\n",
    "      return False\n",
    "    x = int(next/10)\n",
    "    y = next % 10\n",
    "    return (x<=9) & (x>=0) & (y<=9) & (y>=0)\n",
    "def transition():\n",
    "    x = 10\n",
    "    y = 10\n",
    "    var = \"loc\"\n",
    "    actions = ['n', 'w', 's', 'e']\n",
    "    log_print(\"module agent\")\n",
    "    log_print(var+\": [0:\"+ str(x*y)+\"] init 0;\")\n",
    "    for i in range(x):\n",
    "      for j in range(y):\n",
    "        cur = int(i*10+j)\n",
    "\n",
    "        for a in actions:\n",
    "          nextPositions = np.zeros(5)\n",
    "          nextPositionsProbs = np.zeros(5)\n",
    "          for k in range(len(actions)):\n",
    "            act_prob = actions[k]\n",
    "            prob = 0.7 if a==act_prob else 0.1\n",
    "            next = nextPosition(cur, act_prob)\n",
    "            nextPositions[k+1] = next\n",
    "            if inBound(next):\n",
    "              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob\n",
    "        \n",
    "          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur\n",
    "          nextPositions = nextPositions.astype(int)\n",
    "          rule = \"\"\n",
    "          for k in range(len(nextPositionsProbs)):\n",
    "            if nextPositionsProbs[k]>0 :\n",
    "              rule += str(nextPositionsProbs[k])[0:3] + \":(\" + var +\"'=\"+str(nextPositions[k]) +\")+\"\n",
    "          rule = rule[:-1] + \";\"\n",
    "          log_print(\"[\"+a+\"]\", var+\"=\"+str(cur), \"->\", rule)\n",
    "    log_print(\"enmodule\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "Oank8dn91mnE"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "cfoAMwlAsZ4J"
   },
   "outputs": [],
   "source": [
    "def model():\n",
    "  log_print(\"pomdp\")\n",
    "def observables(var_obs):\n",
    "  log_print(\"observables \"+var_obs+\" endobservables\")\n",
    "def label(var_obs):\n",
    "  log_print(\"label \\\"end\\\" = \"+var_obs+\"= 100;\")\n",
    "def rewards(var,var2):\n",
    "  log_print(\"rewards \\\"dd\\\"\")\n",
    "  log_print(\"\\t\"+var+\" = 0 : 10;\")\n",
    "  log_print(\"endrewards\")\n",
    "def nextPosition(cur, a):\n",
    "  next = cur.copy()\n",
    "  if a == 'n':\n",
    "     next[1] += 1\n",
    "  elif a == 'w':\n",
    "    next[0] -= 1\n",
    "  elif a == 's':\n",
    "    next[1] -= 10\n",
    "  elif a =='e':\n",
    "    next[0] += 1\n",
    "  return next\n",
    "def state(cur):\n",
    "  return str(int(cur[0]*10+cur[1]))\n",
    "def inBound(next, xMax, yMax):\n",
    "  x = next[0]\n",
    "  y = next[1]\n",
    "  return (x<xMax) & (x>=0) & (y<yMax) & (y>=0)\n",
    "def obsF(cur, xMax, yMax):\n",
    "  directions = [  [-1,1], [0,1],[1,1],\n",
    "                [-1,0], [0,0], [1,0], \n",
    "                [-1,-1], [0,-1],[1,-1]]\n",
    "  #directions =[[1,0], [0,0]]\n",
    "  n_neighbor = len(directions)\n",
    "  neighbors = [0]*n_neighbor\n",
    "  probs = np.ones(n_neighbor)\n",
    "\n",
    "                   \n",
    "  for direction in range(len(directions)):\n",
    "    next = np.sum([cur, directions[direction]], axis= 0)\n",
    "    neighbors[direction] = next\n",
    "    if not inBound(next, xMax, yMax):\n",
    "      probs[direction] = 0\n",
    "  sum_probs = np.sum(probs)\n",
    "  for i in range(n_neighbor):\n",
    "    probs[i] /= sum_probs\n",
    "\n",
    "  result = [neighbors, probs]\n",
    "  return result\n",
    "def transition( xMax, yMax, targetX, targetY):\n",
    "  x = xMax\n",
    "  y = yMax\n",
    "  \n",
    "  var = \"location\"\n",
    "  var2 = \"obsLocation\"\n",
    "  model()\n",
    "  observables(var2)\n",
    "\n",
    "  actions = ['n', 'w', 's', 'e']\n",
    "  log_print(\"module agent\")\n",
    "  log_print(var+\": [0.. 100] init 0;\")\n",
    "  log_print(var2+\": [0.. 100] init 0;\")\n",
    "  for i in range(x):\n",
    "    for j in range(y):\n",
    "      cur = [i ,j].copy()\n",
    "      if i==targetX and j == targetY:\n",
    "        log_print(\"[n] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "        log_print(\"[s] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "        log_print(\"[w] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "        log_print(\"[e] \"+var+\"=\"+state(cur)+\"->\"+\"(\"+var+\"'=\"+state(cur)+\")&(\"+var2+\"'=100);\")\n",
    "      else:\n",
    "        for a in actions:\n",
    "          nextPositions = [None]* (len(actions)+1)\n",
    "          nextPositionsProbs = [0]* (len(actions)+1)\n",
    "          for k in range(len(actions)):\n",
    "            act_prob = actions[k]\n",
    "            prob = 0.7 if a==act_prob else 0.1\n",
    "            next = nextPosition(cur, act_prob)\n",
    "            nextPositions[k+1] = next\n",
    "            if inBound(next, xMax, yMax):\n",
    "              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob\n",
    "        \n",
    "          nextPositions[0] = cur\n",
    "          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur\n",
    "          pre_rule = \"[\"+a+\"] \"+ var+\"=\"+state(cur)+ \" -> \"\n",
    "          rule = \"\"\n",
    "          ruleB = \"\"\n",
    "          for k in range(len(nextPositionsProbs)):\n",
    "            prob_a = nextPositionsProbs[k]\n",
    "            if prob_a >0 :\n",
    "              rule += str(nextPositionsProbs[k])[0:3] + \":(\" + var +\"'=\"+state(nextPositions[k]) +\")+\"\n",
    "              \n",
    "              observations, observations_probs = obsF(nextPositions[k], xMax, yMax)\n",
    "              for l in range(len(observations)):\n",
    "                prob_b = observations_probs[l]\n",
    "                if prob_b>0:\n",
    "                  ruleB += str(prob_a* prob_b) + \":(\" + var + \"'=\" + state(nextPositions[k]) + \")\" + \" & (\"+var2+\"'=\" + state(observations[l]) + \")+\"     \n",
    "          \n",
    "          rule = rule[:-1] + \";\"\n",
    "          ruleB = ruleB[:-1]+\";\"\n",
    "          #log_print(\"\"+ pre_rule+rule)\n",
    "          log_print( pre_rule+ruleB)\n",
    "  log_print(\"endmodule\")\n",
    "  label(var2)\n",
    "  rewards(var, var2)\n",
    "transition(5,5, 4,4)   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "id": "902QoeCrosSQ"
   },
   "outputs": [],
   "source": [
    "def model():\n",
    "  log_print(\"pomdp\")\n",
    "def observables(var_obs):\n",
    "  log_print(\"observables obsX obsY endobservables\")\n",
    "def label(var_obs):\n",
    "  log_print(\"label \\\"end\\\" = x =10 & y = 10;\")\n",
    "def rewards(var,var2):\n",
    "  log_print(\"rewards \\\"dd\\\"\")\n",
    "  log_print(\"\\t x = 10 & y = 10 : 1;\")\n",
    "  log_print(\"endrewards\")\n",
    "def nextPosition(cur, a):\n",
    "  next = cur.copy()\n",
    "  if a == 'n':\n",
    "     next[1] += 1\n",
    "  elif a == 'w':\n",
    "    next[0] -= 1\n",
    "  elif a == 's':\n",
    "    next[1] -= 10\n",
    "  elif a =='e':\n",
    "    next[0] += 1\n",
    "  return next\n",
    "def state(cur):\n",
    "  return str(int(cur[0]*10+cur[1]))\n",
    "def inBound(next, xMax, yMax):\n",
    "  x = next[0]\n",
    "  y = next[1]\n",
    "  return (x<xMax) & (x>=0) & (y<yMax) & (y>=0)\n",
    "def obsF(cur, xMax, yMax):\n",
    "  directions = [  [-1,1], [0,1],[1,1],\n",
    "                [-1,0], [0,0], [1,0], \n",
    "                [-1,-1], [0,-1],[1,-1]]\n",
    "  directions =[[1,0], [0,0]]\n",
    "  n_neighbor = len(directions)\n",
    "  neighbors = [0]*n_neighbor\n",
    "  probs = np.ones(n_neighbor)\n",
    "\n",
    "                   \n",
    "  for direction in range(len(directions)):\n",
    "    next = np.sum([cur, directions[direction]], axis= 0)\n",
    "    neighbors[direction] = next\n",
    "    if not inBound(next, xMax, yMax):\n",
    "      probs[direction] = 0\n",
    "  sum_probs = np.sum(probs)\n",
    "  for i in range(n_neighbor):\n",
    "    probs[i] /= sum_probs\n",
    "\n",
    "  result = [neighbors, probs]\n",
    "  return result\n",
    "def transition( xMax, yMax, targetX, targetY):\n",
    "  x = xMax\n",
    "  y = yMax\n",
    "  \n",
    "  var = \"location\"\n",
    "  var2 = \"obsLocation\"\n",
    "  model()\n",
    "  observables(var2)\n",
    "\n",
    "  actions = ['n', 'w', 's', 'e']\n",
    "  log_print(\"module agent\")\n",
    "  log_print(\"x\"+\": [0.. 100] init 0;\")\n",
    "  log_print(\"y\"+\": [0.. 100] init 0;\")\n",
    "  log_print(\"obsX\"+\": [0.. 100] init 0;\")\n",
    "  log_print(\"obsY\"+\": [0.. 100] init 0;\")\n",
    "  for i in range(x):\n",
    "    for j in range(y):\n",
    "      cur = [i ,j].copy()\n",
    "      if i==targetX and j == targetY:\n",
    "        tp = \"[n] x=targetX & y=targetY : (x'=100)&(y'=100)&(obsX'=100)&(obsY=100)\"\n",
    "        tp = tp.replace(\"targetX\",str(targetX)).replace(\"targetY\",str(targetY))\n",
    "        log_print(tp)\n",
    "        log_print(tp.replace(\"[n]\",\"[w]\"))\n",
    "        log_print(tp.replace(\"[n]\",\"[s]\"))\n",
    "        log_print(tp.replace(\"[n]\",\"[e]\"))\n",
    "      else:\n",
    "        for a in actions:\n",
    "          nextPositions = [None]* (len(actions)+1)\n",
    "          nextPositionsProbs = [0]* (len(actions)+1)\n",
    "          for k in range(len(actions)):\n",
    "            act_prob = actions[k]\n",
    "            prob = 0.7 if a==act_prob else 0.1\n",
    "            next = nextPosition(cur, act_prob)\n",
    "            nextPositions[k+1] = next\n",
    "            if inBound(next, xMax, yMax):\n",
    "              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob\n",
    "        \n",
    "          nextPositions[0] = cur\n",
    "          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur\n",
    "          pre_rule = \"[\"+a+\"] \" + \"x=\"+str(cur[0])+ \" & y=\"+str(cur[1])+ \"-> \"\n",
    "          rule = \"\"\n",
    "          ruleB = \"\"\n",
    "          for k in range(len(nextPositionsProbs)):\n",
    "            prob_a = nextPositionsProbs[k]\n",
    "            if prob_a >0 :\n",
    "              rule += str(nextPositionsProbs[k])[0:3] + \":(\" + var +\"'=\"+state(nextPositions[k]) +\")+\"\n",
    "              \n",
    "              observations, observations_probs = obsF(nextPositions[k], xMax, yMax)\n",
    "              for l in range(len(observations)):\n",
    "                prob_b = observations_probs[l]\n",
    "                if prob_b>0:\n",
    "                  nxtX = str(nextPositions[k][0])\n",
    "                  nxtY = str(nextPositions[k][1])\n",
    "                  nxtX_obs = str(observations[l][0])\n",
    "                  nxtY_obs = str(observations[l][1])\n",
    "                  #ruleB += str(prob_a* prob_b) + \":(\" + var + \"'=\" + state(nextPositions[k]) + \")\" + \" & (\"+var2+\"'=\" + state(observations[l]) + \")+\"     \n",
    "                  tp = \"prob_a*prob_b : (x'=nxtX)&(y'=nxtY)&(obsX'=nxtX_obs)&(obsY'=nxtY_obs) +\"\n",
    "                  tp = tp.replace(\"prob_a*prob_b\", str(prob_a*prob_b))\n",
    "                  tp = tp.replace(\"nxtX_obs\", nxtX_obs).replace(\"nxtY_obs\", nxtY_obs)\n",
    "\n",
    "                  tp = tp.replace(\"nxtX\", nxtX).replace(\"nxtY\", nxtY)\n",
    "                  ruleB += tp\n",
    "          rule = rule[:-1] + \";\"\n",
    "          ruleB = ruleB[:-1]+\";\"\n",
    "          #log_print(\"\"+ pre_rule+rule)\n",
    "          log_print( pre_rule+ruleB)\n",
    "  log_print(\"endmodule\")\n",
    "  label(var2)\n",
    "  rewards(var, var2)\n",
    "transition(3,3, 2,2)   "
   ]
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [],
   "name": "generate blind grid for Prism",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
