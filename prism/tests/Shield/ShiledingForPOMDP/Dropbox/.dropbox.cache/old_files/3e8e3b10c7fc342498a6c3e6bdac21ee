# -*- coding: utf-8 -*-
"""generate blind grid for Prism

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DUBxbDT110qgRr-JHZ5oYdLkH7feYbTf
"""

def plot_board(obstacle, beliefState, agent, N):

  from matplotlib import pyplot as plt
  fig, ax = plt.subplots(figsize = (N,N))
  ax.xaxis.set_ticks_position('top')   #将X坐标轴移到上面
  ax.invert_yaxis()  
  #
  x = [i for i in range(N)]
  y = [i for i in range(N)]
  plt.xlim((0,N))
  #plt.ylim((0,N))
  ax.set_ylim(bottom=N, top=0)  # 此处将原点设置为左上角  
  plt.xticks([0.5 + i for i in range(N )], labels = [str(i) for i in range(N)])
  plt.yticks([0.5 + i for i in range(N)], labels = [str(i) for i in range(N)])
  plt.xlabel('X Axis')
  plt.ylabel('Y Axis')
  width = 1
  height =1 

  for left, bottom in obstacle:
    rect = plt.Rectangle((left, bottom), width, height, facecolor="red", alpha = 1)
    ax.add_patch(rect)

  for left, bottom in beliefState:
    rect = plt.Rectangle((left, bottom), width, height, facecolor="blue", alpha = 0.5)
    ax.add_patch(rect)

  #plt.scatter(agent[0] + 0.5, agent[1] +0.5)
  for i in range(N):
    plt.hlines(i, 0, N , alpha = 0.5)
    plt.vlines(i, 0, N , alpha = 0.5)
  plt.grid(False)
  plt.show()


def move(belief, action):
  result = set()
  for x, y in belief:
    for slip in [1, 2]:
      if action == "w":
        nx, ny = max(0, x - slip) , y
      if action == 'e':
        nx, ny = min(N - 1, x + slip), y
      if action == 'n':
        nx, ny = x, max(0, y - slip)
      if action == 's':
        nx, ny = x, min(N - 1, y + slip)
      result.add((nx, ny))
  return list(result)

def generate_rocks(N, R):
  obstacles = set()
  import random
  random.seed(N)
  while len(obstacles) < R:
    obstacle = (random.randint(0, N - 1), random.randint(0, N - 1))
    if obstacle == (0, 0):
      continue
    obstacles.add(obstacle)
  if N == 7:
    obstacles = [(1, 1), (1, 2), (2, 1), (3, 3), (3, 5), (4, 0), (4, 1), (6, 4)]
  
  #print("estimated states " + str(N * N * (3 ** R))), file = f)  #plot_board(obstacles, [], None, N)
  return sorted(list(obstacles))
obstacles = generate_rocks(N, R)

def in_bound(obstacle, lx, ly, rx, ry):
  x, y = obstacle[0], obstacle[1]
  return lx <= x <= rx and ly <= y <= ry

def preamble(R, obstacles, lx, ly, rx, ry):
  print("pomdp"), file = f)  print("observables"), file = f)  observables = ["started"]
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    observables.append("r{}taken".format(i))
  observables.append("done")
  print(", ".join(observables)), file = f)  print("endobservables"), file = f)
def grid():
  print("const int N;"), file = f)  print("const int xMAX = N-1;"), file = f)  print("const int yMAX = N-1;"), file = f)  print("const int xMIN = 0;"), file = f)  print("const int yMIN = 0;"), file = f)  print("const double slippery = 0.1;"), file = f)  print("// How likely is a rock a good rock"), file = f)  print("const double goodrock = 0.5;"), file = f)
def primary_grid(lx, ly, rx, ry):
  print("const int primaryMinX = {};".format(lx)), file = f)  print("const int primaryMinY = {};".format(ly)), file = f)  print("const int primaryMaxX = {};".format(rx)), file = f)  print("const int primaryMaxY = {};".format(ry)), file = f)  print("const int borderSize = 2;"), file = f)  print("const int areaMinX = max(primaryMinX - borderSize, xMIN);"), file = f)  print("const int areaMinY = max(primaryMinY - borderSize, yMIN);"), file = f)  print("const int areaMaxX = min(primaryMaxX + borderSize, xMAX);"), file = f)  print("const int areaMaxY = min(primaryMaxY + borderSize, yMAX);"), file = f)def rock_positions(obstacles, lx, ly, rx, ry):
  for i, (x, y) in enumerate(obstacles):
    if not in_bound((x, y), lx, ly, rx, ry):
      continue
    print("const r{}x = {};".format(i + 1, x)), file = f)    print("const r{}y = {};".format(i + 1, y)), file = f)def constants(obstacles, lx, ly, rx, ry):
  grid()
  primary_grid(lx, ly, rx, ry)
  rock_positions(obstacles, lx, ly, rx, ry)

constants(obstacles, 0, 0, N -1 , N -1)

def formula_finish(is_main):
  print("// We are done when we reach max x location"), file = f)  if is_main:
    print("formula finish = started & x = xMAX;"), file = f)  else:
    string = "formula finish = started & (!bad) & (x = xMAX | ";
    out_primary_bound = "x = primaryMinX - 1 | x = primaryMinX - 2| y = primaryMinY - 1 | y = primaryMinY - 2 | "
    out_primary_bound += "x = primaryMaxX + 1 | x = primaryMaxX + 2| y = primaryMaxY + 1 | y = primaryMaxY + 2);"
    print(string + out_primary_bound), file = f)
def observable_finish():
  print("observable \"seefinish\" = finish;"), file = f)def formula_maxdist():
  print("formula maxdist = xMAX-xMIN+yMAX-yMIN;"), file = f)
def formula_good(is_main, R, obstacles, lx, ly, rx, ry):
  if not is_main:
    print("formula good = finish & done;"), file = f)    return
  prefix = "formula good = finish & done & ("
  ending = ");"
  qual = []
  taken = []
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    qual.append("!r{}qual".format(i))
    taken.append("r{}taken".format(i))
  prefix += "(" + " & ".join(qual) + ") | (" + " | ".join(taken) + ")" + ending
  print(prefix), file = f)
def formula_dist(R, obstacles, lx, ly, rx, ry):
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    print("formula r{}dist = max(r{}x-x,x-r{}x) + max(r{}y-y,y-r{}y);".format(i, i, i, i, i)), file = f)  
def formula_bad(R, obstacles, lx, ly, rx, ry):
  prefix = "formula bad = "
  ending  = ";"
  bad = []
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    bad.append("(r{}dist=0 & !r{}qual)".format(i, i))
  if len(bad) > 0:
    prefix += " | ".join(bad) + ending
  else:
    prefix += "false" + ending;
  print(prefix), file = f)
def observable_at(R, obstacles, lx, ly, rx, ry):
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    print("observable \"atr{}\" = r{}dist <= 0;".format(i, i)), file = f)def observable_near(R, obstacles, lx, ly, rx, ry):
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    print("observable \"nearr{}\" = r{}dist <= 1;".format(i, i)), file = f)
def formula_normdist(R, obstacles, lx, ly, rx, ry):
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    print("formula normdistr{} = (r{}dist <= 1) ? 1 : 2; // min(1+((r{}dist-1)/maxdist), 1.0)".format(i, i, i)), file = f)
def observable_good_bad():
  print("observable \"seebad\" = bad;"), file = f)  print("observable \"seegood\" = good;"), file = f)
def formula_observable(R, is_main, obstacles, lx, ly, rx, ry):
  formula_finish(is_main)
  observable_finish()
  formula_maxdist()
  formula_good(is_main, R, obstacles, lx, ly, rx, ry)
  formula_dist(R, obstacles, lx, ly, rx, ry)
  formula_bad(R, obstacles, lx, ly, rx, ry)
  formula_normdist(R, obstacles, lx, ly, rx, ry)
  observable_at(R, obstacles, lx, ly, rx, ry)
  observable_near(R, obstacles, lx, ly, rx, ry)
  observable_good_bad()
formula_observable(R, False, obstacles, 0, 0, 7, 7)

def master():
  print("module master"), file = f)  print("started : bool init false;"), file = f)  print("done : bool init false;"), file = f)  print(""), file = f)  print("[placement] !started -> (started\'=true);"), file = f)  print("[north] started & !done -> true;"), file = f)  print("[south] started  & !done -> true;"), file = f)  print("[east] started  & !done-> true;"), file = f)  print("[west] started & !done -> true;"), file = f)  print("[finish] finish | done -> (done\'=true);"), file = f)  print("endmodule"), file = f)def robot():
  print("module robot"), file = f)  print("x : [areaMinX..areaMaxX] init primaryMinX;"), file = f)  print("y : [areaMinY..areaMaxX] init primaryMinY;"), file = f)  print(""), file = f)  print("[west] true -> (1-slippery): (x\'=max(x-1,areaMinX)) + slippery: (x\'=max(x-2,areaMinX));"), file = f)  print("[east] true -> (1-slippery): (x\'=min(x+1,areaMaxX)) + slippery: (x\'=min(x+2,areaMaxX));"), file = f)  print("[south]  true -> (1-slippery): (y\'=min(y+1,areaMaxY)) + slippery: (y\'=min(y+2,areaMaxY));"), file = f)  print("[north]  true -> (1-slippery): (y\'=max(y-1,areaMinY)) + slippery: (y\'=max(y-2,areaMinY));"), file = f)  print("endmodule"), file = f)
def one_rock(k):
  rk = "r" + str(k)
  print("module rock1".replace("1", str(k))), file = f)  print("r1qual : bool init false;".replace("r1", rk)), file = f)  print("r1taken : bool init false;".replace("r1", rk)), file = f)  print("r1lastobs : bool init false;".replace("r1", rk)), file = f)  print("[placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);".replace("r1", rk)), file = f)  print("".replace("r1", rk)), file = f)  print("[r1sample] r1dist = 0 & started & !done & !bad & !finish & !r1taken-> 1:(r1taken'=(x = r1x & y = r1y & !r1taken));".replace("r1", rk)), file = f)  print("[r1sample] r1dist = 0 & started & !done & !bad & !finish & r1taken -> true;".replace("r1", rk)), file = f)  print("".replace("r1", rk)), file = f)  print("[r1sense] started & !r1taken & !done & !bad & !finish -> (1/normdistr1): (r1lastobs'=r1qual) +  (1-(1/normdistr1)): (r1lastobs'=!r1qual);".replace("r1", rk)), file = f)  print("[north] true -> (r1lastobs'=false);".replace("r1", rk)), file = f)  print("[south] true -> (r1lastobs'=false);".replace("r1", rk)), file = f)  print("[east] true -> (r1lastobs'=false);".replace("r1", rk)), file = f)  print("[west] true -> (r1lastobs'=false);".replace("r1", rk)), file = f)  print("endmodule".replace("r1", rk)), file = f)def rocks(R, obstacles, lx, ly, rx, ry):
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    one_rock(i)

def reward_cost(R, obstacles, lx, ly, rx, ry):
  reward(R, obstacles, lx, ly, rx, ry)
  cost(R, obstacles, lx, ly, rx, ry)

def reward(R, obstacles, lx, ly, rx, ry, finishGood = 100, finish = 20):
  print("rewards \"rew\""), file = f)  sampleGood = 100
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    print("[r{}sample] r{}qual & !r{}taken : {};".format(i, i, i, sampleGood)), file = f)  
  prefix = "[finish] ("
  ending = "): {};".format(finishGood) ;
  qual = []
  taken = []
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    qual.append("!r{}qual".format(i))
    taken.append("r{}taken".format(i))
  if len(qual) > 0:
    prefix += "(" + " & ".join(qual) + ") | (" + " | ".join(taken) + ")" + ending
    print(prefix), file = f)
  print("[finish] true: {};".format(finish)), file = f)  print("endrewards"), file = f)
def cost(R, obstacles, lx, ly, rx, ry, finishBad = 100, bad = 20):
  
  print("rewards \"cos\""), file = f)  print("//[r1sample] !r1qual & !r1taken : 10; // no need; cause it won\'t r1sample is not enabled if !r1qual"), file = f)  print("//[r2sample] !r2qual & !r1taken: 10; // no need; cause it won\'t r1sample is not enabled if !r1qual"), file = f)  print("//[r1sample] r1taken : 20;"), file = f)  print("//[r2sample] r2taken : 20;"), file = f)  finishBad = 100
  prefix = "[finish] !("
  ending = "): {};".format(finishBad) ;
  qual = []
  taken = []
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    qual.append("!r{}qual".format(i))
    taken.append("r{}taken".format(i))
  if len(qual) > 0:
    prefix += "(" + " & ".join(qual) + ") | (" + " | ".join(taken) + ")" + ending
    print(prefix), file = f)  

  print("bad:{};".format(20)), file = f)  print("[east] true: 1;"), file = f)  print("[west] true: 1;"), file = f)  print("[north] true: 1;"), file = f)  print("[south] true: 1;"), file = f)  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    print("[r{}sense] true: 1;".format(i)), file = f)    
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    print("[r{}sample] true: 1;".format(i)), file = f)  print("endrewards"), file = f)def cost_2():
  print("rewards \"cost\""), file = f)  print("[r1sense] true : 1;"), file = f)  print("[r1sample] !r1qual : 20;"), file = f)  print("[r2sense] true : 1;"), file = f)  print("[r2sample] !r2qual : 20;"), file = f)  print("//[r3sense] true : 1;"), file = f)  print("//[r3sample] !r3qual : 20;"), file = f)  print("[north] true : 1;"), file = f)  print("[south] true : 1;"), file = f)  print("[west] true : 1;"), file = f)  print("[east] true : 1;"), file = f)  print("[finish] true : (!r1taken & r1qual ? 30 : 0) + (!r2taken & r2qual ? 30 : 0) ;//+ (!r3taken & r3qual ? 30 : 0) ;"), file = f)  print("endrewards"), file = f)
def labels(R, obstacles, lx, ly, rx, ry):
  print("label \"notbad\" = !bad;"), file = f)  print("label \"goal\" = good;"), file = f)  prefix = "label \"rockposition\" = "
  ending = ";"
  position = []
  for i in range(1, R + 1):
    if not in_bound(obstacles[i - 1], lx, ly, rx, ry):
      continue
    position.append("(!r{}taken & r{}x = x & r{}y = y)".format(i, i, i))
  #if len(position) > 0:
  #  print(prefix + " | ".join(position) + ending), file = f)
def generate_file(N, R, is_main, lx, ly, rx, ry):
  obstacles = generate_rocks(N, R)
  preamble(R, obstacles, lx, ly, rx, ry)
  constants(obstacles, lx, ly, rx, ry)
  formula_observable(R, is_main, obstacles, lx, ly, rx, ry)
  master()
  robot()
  rocks(R, obstacles, lx, ly, rx, ry)
  labels(R, obstacles, lx, ly, rx, ry)
  reward_cost(R, obstacles, lx, ly, rx, ry)

N = 8
R = 4
obstacles = generate_rocks(N, R)

xMIN = yMIN = 0
xMAX = yMAX = N - 1
generate_file(N, R, True, xMIN, yMIN, xMAX, yMAX)

shieldSize = 4
shieldSizeX = 4
shieldSizeY = 4
for lx in range(0, xMAX, shieldSizeX):
  for ly in range(0, yMAX, shieldSizeY):
    rx, ry = lx + shieldSizeX - 1, ly + shieldSizeY - 1
    print(lx, ly, rx, ry,"------"), file = f)    #if not (lx == 4 and ly == 4):
    #  continue
    #generate_file(N, R, False, lx, ly, rx, ry)

obstacles = generate_rocks(N, R)
print(obstacles), file = f)plot_board(obstacles, [], None, 8)

import numpy as np
import pandas as pd

plot_board(obstacle, [((2,3))],  agent, N)
#plot_board(obstacle, [(2,3),(2,1)],  agent, N)
#plot_board(obstacle, [(4,4)],  agent, N)

obstacle = [(1, 0), (5, 1),  (2, 4), (4, 4), (5,4), (5,5)]
belief = [(2, 1), (1, 1),  (1, 3), (3,4)]
agent= (2,1)
N = 6
plot_board(obstacle, belief, agent, N)

s, w, e, n = 's', 'w', 'e', 'n'
for action in [s, e, e, s, e,  e]:
  belief = move(belief, action)
  plot_board(obstacle, belief, agent, N)



path = "/content/drive/MyDrive/2021-03-25 MO-POMDP/shielding/"
prism_file = "Shili todo list - MO-POMDP - Sheet6.csv"
stompy_file = "Shili todo list - MO-POMDP - Sheet5.csv"
prism = pd.read_csv(path + prism_file)
stompy = pd.read_csv(path + stompy_file)
stompy = stompy.loc[:, ['s', 'o', 'x', 'y', 'r1qual', 'r1taken', 'r1lastobs', 'r2qual', 'r2taken', 'r2lastobs']]

prism.columns

data = prism
feature = "obs"
for i in range(len(data)):
  obs = data.loc[i, feature]
  obs_size = len(data.loc[data.loc[:, feature] == obs, :])
  data.loc[i, "obs_size"] = obs_size

data = stompy
feature = "o"
for i in range(len(data)):
  obs = data.loc[i, feature]
  obs_size = len(data.loc[data.loc[:, feature] == obs, :])
  data.loc[i, "obs_size"] = obs_size

for i in range(10):
  c1 = prism.r1qual == stompy.loc[i, "r1qual"]
  c2 = prism.r1taken == stompy.loc[i, "r1taken"]
  c3 = prism.x == stompy.loc[i, "x"]
  c4 = prism.y == stompy.loc[i, "y"]
  c5 = prism.obs_size == stompy.loc[i, "obs_size"]
  c6 = prism.r2qual == stompy.loc[i, "r2qual"]
  c7 = prism.r2taken == stompy.loc[i, "r2taken"]

  condition = c1 & c2 & c3 & c4 & c6 & c7
  tp = prism.loc[condition, :]

  sc1 = stompy.r1qual == stompy.loc[i, "r1qual"]
  sc2 = stompy.r1taken == stompy.loc[i, "r1taken"]
  sc3 = stompy.x == stompy.loc[i, "x"]
  sc4 = stompy.y == stompy.loc[i, "y"]
  sc5 = stompy.obs_size == stompy.loc[i, "obs_size"]
  sc6 = stompy.r2qual == stompy.loc[i, "r2qual"]
  sc7 = stompy.r2taken == stompy.loc[i, "r2taken"]
  scondition = sc1 & sc2 & sc3 & sc4 & sc5 & sc6 &sc7
  stp = stompy.loc[scondition, :]
  #c1 = prism.r1qual == stompy.loc[i, "r1qual"]
  print(stompy.loc[i,:]), file = f)  print(tp) , file = f)  print(stp) , file = f)  print("++++++++++++++++++++++++++"), file = f)
def bitfield(n):
  tp =[int(digit) for digit in bin(n)[2:]]
  while len(tp)<64:
    tp.insert(0,0)
  return tp# [2:] to chop off the "0b" part

nums = [16167922662260080640,9223372036854775808,18410715276690587648 ]
for n in nums:
  print(bitfield(n)), file = f)
a = [ 13546120693153792]
un = []
for i in range(len(a)):
  startIndex = 0 if (i % 2 ==0) else 64
  tp = bitfield(a[i])
  un2 = []
  for j in range(len(tp)):
    if (tp[j]==1):
      un2.append(j + startIndex)
      un.append(j + startIndex)
  print(un2), file = f)un.sort()
print(un), file = f)
#[3 13 14 15 28 30 31 36 51 53 59 64 72 73 82 83 ]

print(bitfield(13835058055282163712)), file = f)
bucket1 = []
bucket2 = []
index = [54, 72, 72, 74, 74, 82, 82, 53, 55, 55, 73, 73, 75, 75, 83, 52, 54] 
for i in index:
  if (i >=64):
    bucket2.append(i) 
  else:
    bucket1.append(i)
print(bucket1), file = f)print(bucket2), file = f)


un = set()
a=[4608, 135195949751336960]
for i in a:
  un2 = set()
  print(bitfield(i),  len(bitfield(i))), file = f)  tp = bitfield(i)
  for j in range(len(tp)):
    if (tp[j] == 1):
      un.add(j)
      un2.add(j)
  print(un2), file = f)un = (list(un))
un.sort()
print(un, len(un)), file = f)
[3 13 14 15 28 30 31 36 51 53 59 64 72 73 82 83 ]

def nextPosition(cur, a):
    if a == 'n':
      return cur + 10
    elif a == 'w':
      return cur - 1
    elif a == 's':
      return cur - 10
    elif a =='e':
      return cur +1
    else:
      return -1
def inBound(next):
    if (next<0):
      return False
    x = int(next/10)
    y = next % 10
    return (x<=9) & (x>=0) & (y<=9) & (y>=0)
def transition():
    x = 10
    y = 10
    var = "loc"
    actions = ['n', 'w', 's', 'e']
    print("module agent"), file = f)    print(var+": [0:"+ str(x*y)+"] init 0;"), file = f)    for i in range(x):
      for j in range(y):
        cur = int(i*10+j)

        for a in actions:
          nextPositions = np.zeros(5)
          nextPositionsProbs = np.zeros(5)
          for k in range(len(actions)):
            act_prob = actions[k]
            prob = 0.7 if a==act_prob else 0.1
            next = nextPosition(cur, act_prob)
            nextPositions[k+1] = next
            if inBound(next):
              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob
        
          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur
          nextPositions = nextPositions.astype(int)
          rule = ""
          for k in range(len(nextPositionsProbs)):
            if nextPositionsProbs[k]>0 :
              rule += str(nextPositionsProbs[k])[0:3] + ":(" + var +"'="+str(nextPositions[k]) +")+"
          rule = rule[:-1] + ";"
          print("["+a+"]", var+"="+str(cur), "->", rule), file = f)    print("enmodule"), file = f)


def model():
  print("pomdp"), file = f)def observables(var_obs):
  print("observables "+var_obs+" endobservables"), file = f)def label(var_obs):
  print("label \"end\" = "+var_obs+"= 100;"), file = f)def rewards(var,var2):
  print("rewards \"dd\""), file = f)  print("\t"+var+" = 0 : 10;"), file = f)  print("endrewards"), file = f)def nextPosition(cur, a):
  next = cur.copy()
  if a == 'n':
     next[1] += 1
  elif a == 'w':
    next[0] -= 1
  elif a == 's':
    next[1] -= 10
  elif a =='e':
    next[0] += 1
  return next
def state(cur):
  return str(int(cur[0]*10+cur[1]))
def inBound(next, xMax, yMax):
  x = next[0]
  y = next[1]
  return (x<xMax) & (x>=0) & (y<yMax) & (y>=0)
def obsF(cur, xMax, yMax):
  directions = [  [-1,1], [0,1],[1,1],
                [-1,0], [0,0], [1,0], 
                [-1,-1], [0,-1],[1,-1]]
  #directions =[[1,0], [0,0]]
  n_neighbor = len(directions)
  neighbors = [0]*n_neighbor
  probs = np.ones(n_neighbor)

                   
  for direction in range(len(directions)):
    next = np.sum([cur, directions[direction]], axis= 0)
    neighbors[direction] = next
    if not inBound(next, xMax, yMax):
      probs[direction] = 0
  sum_probs = np.sum(probs)
  for i in range(n_neighbor):
    probs[i] /= sum_probs

  result = [neighbors, probs]
  return result
def transition( xMax, yMax, targetX, targetY):
  x = xMax
  y = yMax
  
  var = "location"
  var2 = "obsLocation"
  model()
  observables(var2)

  actions = ['n', 'w', 's', 'e']
  print("module agent"), file = f)  print(var+": [0.. 100] init 0;"), file = f)  print(var2+": [0.. 100] init 0;"), file = f)  for i in range(x):
    for j in range(y):
      cur = [i ,j].copy()
      if i==targetX and j == targetY:
        print("[n] "+var+"="+state(cur)+"->"+"("+var+"'="+state(cur)+")&("+var2+"'=100);"), file = f)        print("[s] "+var+"="+state(cur)+"->"+"("+var+"'="+state(cur)+")&("+var2+"'=100);"), file = f)        print("[w] "+var+"="+state(cur)+"->"+"("+var+"'="+state(cur)+")&("+var2+"'=100);"), file = f)        print("[e] "+var+"="+state(cur)+"->"+"("+var+"'="+state(cur)+")&("+var2+"'=100);"), file = f)      else:
        for a in actions:
          nextPositions = [None]* (len(actions)+1)
          nextPositionsProbs = [0]* (len(actions)+1)
          for k in range(len(actions)):
            act_prob = actions[k]
            prob = 0.7 if a==act_prob else 0.1
            next = nextPosition(cur, act_prob)
            nextPositions[k+1] = next
            if inBound(next, xMax, yMax):
              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob
        
          nextPositions[0] = cur
          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur
          pre_rule = "["+a+"] "+ var+"="+state(cur)+ " -> "
          rule = ""
          ruleB = ""
          for k in range(len(nextPositionsProbs)):
            prob_a = nextPositionsProbs[k]
            if prob_a >0 :
              rule += str(nextPositionsProbs[k])[0:3] + ":(" + var +"'="+state(nextPositions[k]) +")+"
              
              observations, observations_probs = obsF(nextPositions[k], xMax, yMax)
              for l in range(len(observations)):
                prob_b = observations_probs[l]
                if prob_b>0:
                  ruleB += str(prob_a* prob_b) + ":(" + var + "'=" + state(nextPositions[k]) + ")" + " & ("+var2+"'=" + state(observations[l]) + ")+"     
          
          rule = rule[:-1] + ";"
          ruleB = ruleB[:-1]+";"
          #print(""+ pre_rule+rule), file = f)          print( pre_rule+ruleB), file = f)  print("endmodule"), file = f)  label(var2)
  rewards(var, var2)
transition(5,5, 4,4)

def model():
  print("pomdp"), file = f)def observables(var_obs):
  print("observables obsX obsY endobservables"), file = f)def label(var_obs):
  print("label \"end\" = x =10 & y = 10;"), file = f)def rewards(var,var2):
  print("rewards \"dd\""), file = f)  print("\t x = 10 & y = 10 : 1;"), file = f)  print("endrewards"), file = f)def nextPosition(cur, a):
  next = cur.copy()
  if a == 'n':
     next[1] += 1
  elif a == 'w':
    next[0] -= 1
  elif a == 's':
    next[1] -= 10
  elif a =='e':
    next[0] += 1
  return next
def state(cur):
  return str(int(cur[0]*10+cur[1]))
def inBound(next, xMax, yMax):
  x = next[0]
  y = next[1]
  return (x<xMax) & (x>=0) & (y<yMax) & (y>=0)
def obsF(cur, xMax, yMax):
  directions = [  [-1,1], [0,1],[1,1],
                [-1,0], [0,0], [1,0], 
                [-1,-1], [0,-1],[1,-1]]
  directions =[[1,0], [0,0]]
  n_neighbor = len(directions)
  neighbors = [0]*n_neighbor
  probs = np.ones(n_neighbor)

                   
  for direction in range(len(directions)):
    next = np.sum([cur, directions[direction]], axis= 0)
    neighbors[direction] = next
    if not inBound(next, xMax, yMax):
      probs[direction] = 0
  sum_probs = np.sum(probs)
  for i in range(n_neighbor):
    probs[i] /= sum_probs

  result = [neighbors, probs]
  return result
def transition( xMax, yMax, targetX, targetY):
  x = xMax
  y = yMax
  
  var = "location"
  var2 = "obsLocation"
  model()
  observables(var2)

  actions = ['n', 'w', 's', 'e']
  print("module agent"), file = f)  print("x"+": [0.. 100] init 0;"), file = f)  print("y"+": [0.. 100] init 0;"), file = f)  print("obsX"+": [0.. 100] init 0;"), file = f)  print("obsY"+": [0.. 100] init 0;"), file = f)  for i in range(x):
    for j in range(y):
      cur = [i ,j].copy()
      if i==targetX and j == targetY:
        tp = "[n] x=targetX & y=targetY : (x'=100)&(y'=100)&(obsX'=100)&(obsY=100)"
        tp = tp.replace("targetX",str(targetX)).replace("targetY",str(targetY))
        print(tp), file = f)        print(tp.replace("[n]","[w]")), file = f)        print(tp.replace("[n]","[s]")), file = f)        print(tp.replace("[n]","[e]")), file = f)      else:
        for a in actions:
          nextPositions = [None]* (len(actions)+1)
          nextPositionsProbs = [0]* (len(actions)+1)
          for k in range(len(actions)):
            act_prob = actions[k]
            prob = 0.7 if a==act_prob else 0.1
            next = nextPosition(cur, act_prob)
            nextPositions[k+1] = next
            if inBound(next, xMax, yMax):
              nextPositionsProbs[k+1] = prob # prob of going in direction of act_prob
        
          nextPositions[0] = cur
          nextPositionsProbs[0] = 1 - np.sum(nextPositionsProbs) # prob of stay cur
          pre_rule = "["+a+"] " + "x="+str(cur[0])+ " & y="+str(cur[1])+ "-> "
          rule = ""
          ruleB = ""
          for k in range(len(nextPositionsProbs)):
            prob_a = nextPositionsProbs[k]
            if prob_a >0 :
              rule += str(nextPositionsProbs[k])[0:3] + ":(" + var +"'="+state(nextPositions[k]) +")+"
              
              observations, observations_probs = obsF(nextPositions[k], xMax, yMax)
              for l in range(len(observations)):
                prob_b = observations_probs[l]
                if prob_b>0:
                  nxtX = str(nextPositions[k][0])
                  nxtY = str(nextPositions[k][1])
                  nxtX_obs = str(observations[l][0])
                  nxtY_obs = str(observations[l][1])
                  #ruleB += str(prob_a* prob_b) + ":(" + var + "'=" + state(nextPositions[k]) + ")" + " & ("+var2+"'=" + state(observations[l]) + ")+"     
                  tp = "prob_a*prob_b : (x'=nxtX)&(y'=nxtY)&(obsX'=nxtX_obs)&(obsY'=nxtY_obs) +"
                  tp = tp.replace("prob_a*prob_b", str(prob_a*prob_b))
                  tp = tp.replace("nxtX_obs", nxtX_obs).replace("nxtY_obs", nxtY_obs)

                  tp = tp.replace("nxtX", nxtX).replace("nxtY", nxtY)
                  ruleB += tp
          rule = rule[:-1] + ";"
          ruleB = ruleB[:-1]+";"
          #print(""+ pre_rule+rule), file = f)          print( pre_rule+ruleB), file = f)  print("endmodule"), file = f)  label(var2)
  rewards(var, var2)
transition(3,3, 2,2)