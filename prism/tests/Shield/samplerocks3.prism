pomdp

observables
started, x, y, r1taken, r1lastobs, finish, r2taken, r2lastobs//, r3taken, r3lastobs
endobservables

const int N;
const int xMx = N;
const int yMx = N;
const int xMIN = 0;
const int yMIN = 0;
const double slippery = 0.0;
// Rock positions
const int r1x = 1;
const int r1y = 0;
const int r2x = 1;
const int r2y = 1;

const int r3x = 1;
const int r3y = N;
// How likely is a rock a good rock
const double goodrock = 0.5;
// We are done when we reach max x location
formula done = x = xMx  ;
// Distance between r1 and the robot

formula r1dist = max(r1x-x,x-r1x) + max(r1y-y,y-r1y);
// max distance
formula maxdist = xMx-xMIN+yMx-yMIN;
// Distance between r1 and the robot
formula r2dist = max(r2x-x,x-r2x) + max(r2y-y,y-r2y);
formula r3dist = max(r3x-x,x-r3x) + max(r3y-y,y-r3y);
formula normdistr1 = 1+(r1dist/maxdist);
formula normdistr2 = 1+(r2dist/maxdist);
formula normdistr3 = 1+(r3dist/maxdist);

const double h = 20;
formula d1 = pow( ((r1x-x)*(r1x-x) + (r1y-y)*(r1y-y)), 0.5);
formula d2 = pow(((r2x - x) * (r2x -x) + (r2y -y) * (r2y - y)), 0.5);
formula e1 = (1 + pow(2, -d1/h))/2;
formula e2 = (1 + pow(2, -d2/h))/2;

formula onr1 = (x = r1x & y = r1y);
formula onr2 = (x = r2x & y = r2y);

module master
    started : bool init false;
    finish : bool init false;

    [placement] !started -> (started'=true);
    [north] started & !done -> true;
    [south] started  & !done -> true;
    [east] started  & !done-> true;
    [west] started & !done -> true;
    // once we are, we execute this action a single time to give some rewards
    [finish] done & !finish -> 1:(finish'=true);
endmodule

module rock1
    r1qual : bool init false;
    r1taken : bool init false;
    r1lastobs : bool init false;
    [placement] true -> goodrock : (r1qual'=true) + (1-goodrock) : (r1qual'=false);

    [r1sample] started & onr1 -> 1:(r1taken'=true);
    [r1sense] started & !r1taken & !done-> (e1): (r1lastobs'=r1qual) +  (1-e1): (r1lastobs'=!r1qual);
    [north] true -> (r1lastobs'=false);
    [south] true -> (r1lastobs'=false);
    [east] true -> (r1lastobs'=false);
    [west] true -> (r1lastobs'=false);
endmodule

module rock2
    r2qual : bool init false;
    r2taken : bool init false;
    r2lastobs : bool init false;
    [placement] true -> goodrock : (r2qual'=true) + (1-goodrock) : (r2qual'=false);

    [r2sample] started  & onr2 -> 1:(r2taken'=true);
    [r2sense] started & !r2taken & !done-> (e2): (r2lastobs'=r2qual) +  (1-e2): (r2lastobs'=!r2qual);
    [north] true -> (r2lastobs'=false);
    [south] true -> (r2lastobs'=false);
    [east] true -> (r2lastobs'=false);
    [west] true -> (r2lastobs'=false);
endmodule


//module rock3 = rock1[sample=r3sample, r1sense=r3sense, r1x = r3x, r1y = r3y, r1qual=r3qual,r1taken=r3taken,r1lastobs=r3lastobs] endmodule

module robot
    x : [xMIN..xMx] init 0;
    y : [yMIN..yMx] init 1;

    [west] true -> (1-slippery): (x'=max(x-1,xMIN)) + slippery: (x'=max(x,xMIN));
    [east] true -> (1-slippery): (x'=min(x+1,xMx)) + slippery: (x'=min(x,xMx));
    [north]  true -> (1-slippery): (y'=min(y+1,yMx)) + slippery: (y'=min(y,yMx));
    [south]  true -> (1-slippery): (y'=max(y-1,yMIN)) + slippery: (y'=max(y,yMIN));

endmodule

rewards "rew"
[r1sample] r1qual & !r1taken & onr1: 10;
[r2sample] r2qual & !r1taken & onr2: 10;
[finish] true: 10;
endrewards

rewards "cos"
//outbound
//[sample] !onr2 & !onr1: 100;

[r1sample] onr1 & r1taken : 100;
[r2sample] onr2 & r2taken : 100;
[r1sample] !r1qual & !r1taken & onr1: 10;
[r2sample] !r2qual & !r1taken & onr2: 10;

[west] x = xMIN : 100;
[south] y = yMIN  : 100;
[north] y = yMx : 100;
endrewards

rewards "cost"

    [north] true : 1;
    [south] true : 1;
    [west] true : 1;
    [east] true : 1;

endrewards

label "goal" = finish;
label "rockposition" = (r1x = x & r1y = y) | (r2x = x & r2y = y) | (r3x = x & r3y = y);