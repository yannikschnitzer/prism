mdp
////////////////////////////////////////////////////////////////////////////////
// parameter specification for the generation:
//  number_of_processes  = 6
//  number_of_resources  = 1
//  crit_dist            = {2: (1, 3), 3: (2, 3)}
//  ncrit_dist           = {4: (2, 3), 5: (1, 3)}
//  deadline_dist        = {9: (2, 3), 7: (1, 3)}
//  desired_success      = None
//  energy_capacity      = 300
//  energy_only_crit     = False
//  boost_mode           = True
//  local_model          = True
////////////////////////////////////////////////////////////////////////////////

const int energy_capacity = 300;


//DO NOT CHANGE these constants/////////////////////////////////////////////////
const int t_max = 9;
////////////////////////////////////////////////////////////////////////////////
const int undef = 0;                                                          //
////////////////////////////////////////////////////////////////////////////////
const int ncrit = 2;                                                          //
const int wait = 0;                                                           //
const int crit = 1;                                                           //
////////////////////////////////////////////////////////////////////////////////
const int none = 0;                                                           //
const int process_1 = 1;                                                      //
const int process_2 = 2;                                                      //
const int process_3 = 3;                                                      //
const int process_4 = 4;                                                      //
const int process_5 = 5;                                                      //
const int process_6 = 6;                                                      //
////////////////////////////////////////////////////////////////////////////////


formula localFailure = loc_1=crit & t_1=0 & failure_1;
label "localFailure" = localFailure;
formula noLocalFailure = !localFailure;
label "noLocalFailure" = noLocalFailure;

formula emptyBattery = battery_load=0;
label "emptyBattery" = emptyBattery;
module Battery
	//this battery is only used for process 1
	battery_load: [0..energy_capacity] init energy_capacity;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=ncrit
		->	(battery_load'=max(0, battery_load-2*m_1));
	[tick] loc_1=wait
		->	(battery_load'=max(0, battery_load-1*m_1));
	[tick] loc_1=crit & user_1=process_1 & boost_1=0
		->	(battery_load'=max(0, battery_load-3*m_1));
	[tick] loc_1=crit & user_1=process_1 & boost_1=1
		->	(battery_load'=max(0, battery_load-3*m_1*boost_multiplicator));
endmodule


module Process_1
	t_1: [0..t_max] init 0;
	loc_1: [0..2] init ncrit;
	failure_1: bool init false;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=ncrit & t_1!=0
		->	(t_1'=t_1-1);
	[tick] loc_1=ncrit & t_1=0
		->	2/3: (t_1'=9) & (loc_1'=wait) + 1/3: (t_1'=7) & (loc_1'=wait);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=wait & user_1!=process_1
		->	(t_1'=max(0,t_1-1));
	[tick] loc_1=wait & user_1=process_1
		->	1/3: (loc_1'=crit) & (t_1'=2) & (failure_1'=(2<(boost_1+1)*t_1) ? false : true) + 2/3: (loc_1'=crit) & (t_1'=3) & (failure_1'=(3<(boost_1+1)*t_1) ? false : true);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=crit & t_1>0
		->	(t_1'=max(t_1-(boost_1+1),0));
	[tick] loc_1=crit & t_1=0
		->	2/3: (loc_1'=ncrit) & (t_1'=4) & (failure_1'=false) + 1/3: (loc_1'=ncrit) & (t_1'=5) & (failure_1'=false);
endmodule

module Process_2
	t_2: [0..t_max] init 0;
	loc_2: [0..2] init ncrit;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_2=ncrit & t_2!=0
		->	(t_2'=t_2-1);
	[tick] loc_2=ncrit & t_2=0
		->	(loc_2'=wait);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_2=wait & user_1!=process_2
		->	(t_2'=max(0,t_2-1));
	[tick] loc_2=wait & user_1=process_2
		->	1/3: (loc_2'=crit) & (t_2'=2) + 2/3: (loc_2'=crit) & (t_2'=3);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_2=crit & t_2>0
		->	(t_2'=max(t_2-(boost_1+1),0));
	[tick] loc_2=crit & t_2=0
		->	2/3: (loc_2'=ncrit) & (t_2'=4) + 1/3: (loc_2'=ncrit) & (t_2'=5);
endmodule

module Process_3 = Process_2 [t_2=t_3, loc_2=loc_3, process_2=process_3] endmodule
module Process_4 = Process_2 [t_2=t_4, loc_2=loc_4, process_2=process_4] endmodule
module Process_5 = Process_2 [t_2=t_5, loc_2=loc_5, process_2=process_5] endmodule
module Process_6 = Process_2 [t_2=t_6, loc_2=loc_6, process_2=process_6] endmodule

formula process_1_finishes = (loc_1=crit & t_1=0);
label "process_1_finishes" = process_1_finishes;
formula process_2_finishes = (loc_2=crit & t_2=0);
label "process_2_finishes" = process_2_finishes;
formula process_3_finishes = (loc_3=crit & t_3=0);
label "process_3_finishes" = process_3_finishes;
formula process_4_finishes = (loc_4=crit & t_4=0);
label "process_4_finishes" = process_4_finishes;
formula process_5_finishes = (loc_5=crit & t_5=0);
label "process_5_finishes" = process_5_finishes;
formula process_6_finishes = (loc_6=crit & t_6=0);
label "process_6_finishes" = process_6_finishes;
module Resources
	user_1: [0..6] init none;
	boost_1: [0..1] init 0;
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_1
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1);
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	//self loop when user=process_1
	[tick] user_1=process_1 & !process_1_finishes
		->	true;
	//from user=process_1 to user=none
	[tick] user_1=process_1 & process_1_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait & loc_5!=wait & loc_6!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_1 to user=process_x (x!=1)
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_1 & process_1_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	[tick] user_1=process_1 & process_1_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	[tick] user_1=process_1 & process_1_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=0);
	[tick] user_1=process_1 & process_1_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_2
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2);
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	//self loop when user=process_2
	[tick] user_1=process_2 & !process_2_finishes
		->	true;
	//from user=process_2 to user=none
	[tick] user_1=process_2 & process_2_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait & loc_5!=wait & loc_6!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_2 to user=process_x (x!=2)
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_2 & process_2_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	[tick] user_1=process_2 & process_2_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	[tick] user_1=process_2 & process_2_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=0);
	[tick] user_1=process_2 & process_2_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_3
	[tick] user_1=none & loc_3=wait
		->	(user_1'=process_3);
	[tick] user_1=none & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	//self loop when user=process_3
	[tick] user_1=process_3 & !process_3_finishes
		->	true;
	//from user=process_3 to user=none
	[tick] user_1=process_3 & process_3_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait & loc_5!=wait & loc_6!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_3 to user=process_x (x!=3)
	[tick] user_1=process_3 & process_3_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_3 & process_3_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_3 & process_3_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	[tick] user_1=process_3 & process_3_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=0);
	[tick] user_1=process_3 & process_3_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_4
	[tick] user_1=none & loc_4=wait
		->	(user_1'=process_4);
	[tick] user_1=none & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	//self loop when user=process_4
	[tick] user_1=process_4 & !process_4_finishes
		->	true;
	//from user=process_4 to user=none
	[tick] user_1=process_4 & process_4_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait & loc_5!=wait & loc_6!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_4 to user=process_x (x!=4)
	[tick] user_1=process_4 & process_4_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_4 & process_4_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_4 & process_4_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	[tick] user_1=process_4 & process_4_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=0);
	[tick] user_1=process_4 & process_4_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_5
	[tick] user_1=none & loc_5=wait
		->	(user_1'=process_5);
	[tick] user_1=none & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=1);
	//self loop when user=process_5
	[tick] user_1=process_5 & !process_5_finishes
		->	true;
	//from user=process_5 to user=none
	[tick] user_1=process_5 & process_5_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait & loc_5!=wait & loc_6!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_5 to user=process_x (x!=5)
	[tick] user_1=process_5 & process_5_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_5 & process_5_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_5 & process_5_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_5 & process_5_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_5 & process_5_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_5 & process_5_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	[tick] user_1=process_5 & process_5_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_5 & process_5_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	[tick] user_1=process_5 & process_5_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=1);
	[tick] user_1=process_5 & process_5_finishes & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_6
	[tick] user_1=none & loc_6=wait
		->	(user_1'=process_6);
	[tick] user_1=none & loc_6=wait
		->	(user_1'=process_6) & (boost_1'=1);
	//self loop when user=process_6
	[tick] user_1=process_6 & !process_6_finishes
		->	true;
	//from user=process_6 to user=none
	[tick] user_1=process_6 & process_6_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait & loc_5!=wait & loc_6!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_6 to user=process_x (x!=6)
	[tick] user_1=process_6 & process_6_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_6 & process_6_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_6 & process_6_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_6 & process_6_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_6 & process_6_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_6 & process_6_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	[tick] user_1=process_6 & process_6_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_6 & process_6_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	[tick] user_1=process_6 & process_6_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=1);
	[tick] user_1=process_6 & process_6_finishes & loc_5=wait
		->	(user_1'=process_5) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//self loop when user=none
	[tick] user_1=none & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait & loc_5!=wait & loc_6!=wait
		->	true;
endmodule

//every third processor is twice as expensive
const m_1 = 1;
const m_2 = 1;
const m_3 = 2;
const m_4 = 1;
const m_5 = 1;
const m_6 = 2;
const boost_multiplicator = 3;

rewards "energyLocal"
	//energy consumption of processor 1 only
	[tick] loc_1=ncrit: 2*m_1;
	[tick] loc_1=wait: 1*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=0: 3*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=1: 3*m_1*boost_multiplicator;
endrewards


rewards "utilityLocal"
	[tick] loc_1=crit & t_1=0 & !failure_1 & !emptyBattery: 1;
endrewards