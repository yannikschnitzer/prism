mdp
////////////////////////////////////////////////////////////////////////////////
// parameter specification for the generation:
//  number_of_processes  = 2
//  number_of_resources  = 1
//  crit_dist            = {2: (1, 3), 3: (2, 3)}
//  ncrit_dist           = {4: (2, 3), 5: (1, 3)}
//  deadline_dist        = {9: (2, 3), 7: (1, 3)}
//  desired_success      = None
//  energy_capacity      = 100
//  energy_only_crit     = False
//  boost_mode           = True
//  local_model          = True
////////////////////////////////////////////////////////////////////////////////

const int energy_capacity = 100;


//DO NOT CHANGE these constants/////////////////////////////////////////////////
const int t_max = 9;
////////////////////////////////////////////////////////////////////////////////
const int undef = 0;                                                          //
////////////////////////////////////////////////////////////////////////////////
const int ncrit = 2;                                                          //
const int wait = 0;                                                           //
const int crit = 1;                                                           //
////////////////////////////////////////////////////////////////////////////////
const int none = 0;                                                           //
const int process_1 = 1;                                                      //
const int process_2 = 2;                                                      //
////////////////////////////////////////////////////////////////////////////////


formula localFailure = loc_1=crit & t_1=0 & failure_1;
label "localFailure" = localFailure;
formula noLocalFailure = !localFailure;
label "noLocalFailure" = noLocalFailure;

formula emptyBattery = battery_load=0;
label "emptyBattery" = emptyBattery;
module Battery
	//this battery is only used for process 1
	battery_load: [0..energy_capacity] init energy_capacity;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=ncrit
		->	(battery_load'=max(0, battery_load-2*m_1));
	[tick] loc_1=wait
		->	(battery_load'=max(0, battery_load-1*m_1));
	[tick] loc_1=crit & user_1=process_1 & boost_1=0
		->	(battery_load'=max(0, battery_load-3*m_1));
	[tick] loc_1=crit & user_1=process_1 & boost_1=1
		->	(battery_load'=max(0, battery_load-3*m_1*boost_multiplicator));
endmodule


module Process_1
	t_1: [0..t_max] init 0;
	loc_1: [0..2] init ncrit;
	failure_1: bool init false;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=ncrit & t_1!=0
		->	(t_1'=t_1-1);
	[tick] loc_1=ncrit & t_1=0
		->	2/3: (t_1'=9) & (loc_1'=wait) + 1/3: (t_1'=7) & (loc_1'=wait);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=wait & user_1!=process_1
		->	(t_1'=max(0,t_1-1));
	[tick] loc_1=wait & user_1=process_1
		->	1/3: (loc_1'=crit) & (t_1'=2) & (failure_1'=(2<(boost_1+1)*t_1) ? false : true) + 2/3: (loc_1'=crit) & (t_1'=3) & (failure_1'=(3<(boost_1+1)*t_1) ? false : true);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=crit & t_1>0
		->	(t_1'=max(t_1-(boost_1+1),0));
	[tick] loc_1=crit & t_1=0
		->	2/3: (loc_1'=ncrit) & (t_1'=4) & (failure_1'=false) + 1/3: (loc_1'=ncrit) & (t_1'=5) & (failure_1'=false);
endmodule

module Process_2
	t_2: [0..t_max] init 0;
	loc_2: [0..2] init ncrit;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_2=ncrit & t_2!=0
		->	(t_2'=t_2-1);
	[tick] loc_2=ncrit & t_2=0
		->	(loc_2'=wait);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_2=wait & user_1!=process_2
		->	(t_2'=max(0,t_2-1));
	[tick] loc_2=wait & user_1=process_2
		->	1/3: (loc_2'=crit) & (t_2'=2) + 2/3: (loc_2'=crit) & (t_2'=3);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_2=crit & t_2>0
		->	(t_2'=max(t_2-(boost_1+1),0));
	[tick] loc_2=crit & t_2=0
		->	2/3: (loc_2'=ncrit) & (t_2'=4) + 1/3: (loc_2'=ncrit) & (t_2'=5);
endmodule


formula process_1_finishes = (loc_1=crit & t_1=0);
label "process_1_finishes" = process_1_finishes;
formula process_2_finishes = (loc_2=crit & t_2=0);
label "process_2_finishes" = process_2_finishes;
module Resources
	user_1: [0..2] init none;
	boost_1: [0..1] init 0;
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_1
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1);
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	//self loop when user=process_1
	[tick] user_1=process_1 & !process_1_finishes
		->	true;
	//from user=process_1 to user=none
	[tick] user_1=process_1 & process_1_finishes & loc_1!=wait & loc_2!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_1 to user=process_x (x!=1)
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_2
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2);
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	//self loop when user=process_2
	[tick] user_1=process_2 & !process_2_finishes
		->	true;
	//from user=process_2 to user=none
	[tick] user_1=process_2 & process_2_finishes & loc_1!=wait & loc_2!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_2 to user=process_x (x!=2)
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//self loop when user=none
	[tick] user_1=none & loc_1!=wait & loc_2!=wait
		->	true;
endmodule

//every third processor is twice as expensive
const m_1 = 1;
const m_2 = 1;
const boost_multiplicator = 3;

rewards "energyLocal"
	//energy consumption of processor 1 only
	[tick] loc_1=ncrit: 2*m_1;
	[tick] loc_1=wait: 1*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=0: 3*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=1: 3*m_1*boost_multiplicator;
endrewards


rewards "utilityLocal"
	[tick] loc_1=crit & t_1=0 & !failure_1 & !emptyBattery: 1;
endrewards