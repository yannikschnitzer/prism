mdp
////////////////////////////////////////////////////////////////////////////////
// parameter specification for the generation:
//  number_of_processes  = 2
//  number_of_resources  = 1
//  crit_dist            = {2: (1, 3), 3: (2, 3)}
//  ncrit_dist           = {4: (2, 3), 5: (1, 3)}
//  deadline_dist        = {9: (2, 3), 7: (1, 3)}
//  desired_success      = 2
//  energy_capacity      = None
//  energy_only_crit     = False
//  boost_mode           = True
//  local_model          = False
////////////////////////////////////////////////////////////////////////////////

const int desired_success = 2;


//DO NOT CHANGE these constants/////////////////////////////////////////////////
const int t_max = 9;
////////////////////////////////////////////////////////////////////////////////
const int undef = 0;                                                          //
////////////////////////////////////////////////////////////////////////////////
const int ncrit = 2;                                                          //
const int wait = 0;                                                           //
const int crit = 1;                                                           //
////////////////////////////////////////////////////////////////////////////////
const int none = 0;                                                           //
const int process_1 = 1;                                                      //
const int process_2 = 2;                                                      //
////////////////////////////////////////////////////////////////////////////////


formula globalFailure = (loc_1=crit & t_1=0 & failure_1 | loc_2=crit & t_2=0 & failure_2);
label "globalFailure" = globalFailure;
formula noGlobalFailure = !globalFailure;
label "noGlobalFailure" = noGlobalFailure;
formula localFailure = loc_1=crit & t_1=0 & failure_1;
label "localFailure" = localFailure;
formula noLocalFailure = !localFailure;
label "noLocalFailure" = noLocalFailure;


formula success = counted_success=desired_success;
label "success" = success;
module Success
	counted_success: [0..desired_success] init 0;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=crit & t_1=0 & !failure_1
		->	(counted_success'=min(counted_success+1,desired_success));
	[tick] !(loc_1=crit & t_1=0 & !failure_1)
		->	true;
	[tick] loc_2=crit & t_2=0 & !failure_2
		->	(counted_success'=min(counted_success+1,desired_success));
	[tick] !(loc_2=crit & t_2=0 & !failure_2)
		->	true;
endmodule

module Process_1
	t_1: [0..t_max] init 0;
	loc_1: [0..2] init ncrit;
	failure_1: bool init false;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=ncrit & t_1!=0
		->	(t_1'=t_1-1);
	[tick] loc_1=ncrit & t_1=0
		->	2/3: (t_1'=9) & (loc_1'=wait) + 1/3: (t_1'=7) & (loc_1'=wait);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=wait & user_1!=process_1
		->	(t_1'=max(0,t_1-1));
	[tick] loc_1=wait & user_1=process_1
		->	1/3: (loc_1'=crit) & (t_1'=2) & (failure_1'=(2<(boost_1+1)*t_1) ? false : true) + 2/3: (loc_1'=crit) & (t_1'=3) & (failure_1'=(3<(boost_1+1)*t_1) ? false : true);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=crit & t_1>0
		->	(t_1'=max(t_1-(boost_1+1),0));
	[tick] loc_1=crit & t_1=0
		->	2/3: (loc_1'=ncrit) & (t_1'=4) & (failure_1'=false) + 1/3: (loc_1'=ncrit) & (t_1'=5) & (failure_1'=false);
endmodule

module Process_2 = Process_1 [t_1=t_2, loc_1=loc_2, failure_1=failure_2, process_1=process_2] endmodule

formula process_1_finishes = (loc_1=crit & t_1=0);
label "process_1_finishes" = process_1_finishes;
formula process_2_finishes = (loc_2=crit & t_2=0);
label "process_2_finishes" = process_2_finishes;
module Resources
	user_1: [0..2] init none;
	boost_1: [0..1] init 0;
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_1
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1);
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	//self loop when user=process_1
	[tick] user_1=process_1 & !process_1_finishes
		->	true;
	//from user=process_1 to user=none
	[tick] user_1=process_1 & process_1_finishes & loc_1!=wait & loc_2!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_1 to user=process_x (x!=1)
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_2
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2);
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	//self loop when user=process_2
	[tick] user_1=process_2 & !process_2_finishes
		->	true;
	//from user=process_2 to user=none
	[tick] user_1=process_2 & process_2_finishes & loc_1!=wait & loc_2!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_2 to user=process_x (x!=2)
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//self loop when user=none
	[tick] user_1=none & loc_1!=wait & loc_2!=wait
		->	true;
endmodule

//every third processor is twice as expensive
const m_1 = 1;
const m_2 = 1;
const boost_multiplicator = 3;
rewards "energyGlobal"
	//energy consumption of all the processors
	[tick] loc_1=ncrit: 2*m_1;
	[tick] loc_1=wait: 1*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=0: 3*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=1: 3*m_1*boost_multiplicator;
	[tick] loc_2=ncrit: 2*m_2;
	[tick] loc_2=wait: 1*m_2;
	[tick] loc_2=crit & user_1=process_2 & boost_1=0: 3*m_2;
	[tick] loc_2=crit & user_1=process_2 & boost_1=1: 3*m_2*boost_multiplicator;
endrewards

rewards "energyLocal"
	//energy consumption of processor 1 only
	[tick] loc_1=ncrit: 2*m_1;
	[tick] loc_1=wait: 1*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=0: 3*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=1: 3*m_1*boost_multiplicator;
endrewards

rewards "utilityGlobal"
	[tick] loc_1=crit & t_1=0 & !failure_1: 1;
	[tick] loc_2=crit & t_2=0 & !failure_2: 1;
endrewards

rewards "utilityLocal"
	[tick] loc_1=crit & t_1=0 & !failure_1: 1;
endrewards