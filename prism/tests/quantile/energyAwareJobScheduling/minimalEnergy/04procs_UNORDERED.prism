mdp
////////////////////////////////////////////////////////////////////////////////
// parameter specification for the generation:
//  number_of_processes  = 4
//  number_of_resources  = 1
//  crit_dist            = {2: (1, 3), 3: (2, 3)}
//  ncrit_dist           = {4: (2, 3), 5: (1, 3)}
//  deadline_dist        = {9: (2, 3), 7: (1, 3)}
//  desired_success      = 4
//  energy_capacity      = None
//  energy_only_crit     = False
//  boost_mode           = True
//  local_model          = False
////////////////////////////////////////////////////////////////////////////////

const int desired_success = 4;


//DO NOT CHANGE these constants/////////////////////////////////////////////////
const int t_max = 9;
////////////////////////////////////////////////////////////////////////////////
const int undef = 0;                                                          //
////////////////////////////////////////////////////////////////////////////////
const int ncrit = 2;                                                          //
const int wait = 0;                                                           //
const int crit = 1;                                                           //
////////////////////////////////////////////////////////////////////////////////
const int none = 0;                                                           //
const int process_1 = 1;                                                      //
const int process_2 = 2;                                                      //
const int process_3 = 3;                                                      //
const int process_4 = 4;                                                      //
////////////////////////////////////////////////////////////////////////////////


formula globalFailure = (loc_1=crit & t_1=0 & failure_1 | loc_2=crit & t_2=0 & failure_2 | loc_3=crit & t_3=0 & failure_3 | loc_4=crit & t_4=0 & failure_4);
label "globalFailure" = globalFailure;
formula noGlobalFailure = !globalFailure;
label "noGlobalFailure" = noGlobalFailure;
formula localFailure = loc_1=crit & t_1=0 & failure_1;
label "localFailure" = localFailure;
formula noLocalFailure = !localFailure;
label "noLocalFailure" = noLocalFailure;


formula success = counted_success=desired_success;
label "success" = success;
module Success
	counted_success: [0..desired_success] init 0;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=crit & t_1=0 & !failure_1
		->	(counted_success'=min(counted_success+1,desired_success));
	[tick] !(loc_1=crit & t_1=0 & !failure_1)
		->	true;
	[tick] loc_2=crit & t_2=0 & !failure_2
		->	(counted_success'=min(counted_success+1,desired_success));
	[tick] !(loc_2=crit & t_2=0 & !failure_2)
		->	true;
	[tick] loc_3=crit & t_3=0 & !failure_3
		->	(counted_success'=min(counted_success+1,desired_success));
	[tick] !(loc_3=crit & t_3=0 & !failure_3)
		->	true;
	[tick] loc_4=crit & t_4=0 & !failure_4
		->	(counted_success'=min(counted_success+1,desired_success));
	[tick] !(loc_4=crit & t_4=0 & !failure_4)
		->	true;
endmodule

module Process_1
	t_1: [0..t_max] init 0;
	loc_1: [0..2] init ncrit;
	failure_1: bool init false;
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=ncrit & t_1!=0
		->	(t_1'=t_1-1);
	[tick] loc_1=ncrit & t_1=0
		->	2/3: (t_1'=9) & (loc_1'=wait) + 1/3: (t_1'=7) & (loc_1'=wait);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=wait & user_1!=process_1
		->	(t_1'=max(0,t_1-1));
	[tick] loc_1=wait & user_1=process_1
		->	1/3: (loc_1'=crit) & (t_1'=2) & (failure_1'=(2<(boost_1+1)*t_1) ? false : true) + 2/3: (loc_1'=crit) & (t_1'=3) & (failure_1'=(3<(boost_1+1)*t_1) ? false : true);
	//-------------------------------------------------------------------------------------------------------------------------
	[tick] loc_1=crit & t_1>0
		->	(t_1'=max(t_1-(boost_1+1),0));
	[tick] loc_1=crit & t_1=0
		->	2/3: (loc_1'=ncrit) & (t_1'=4) & (failure_1'=false) + 1/3: (loc_1'=ncrit) & (t_1'=5) & (failure_1'=false);
endmodule

module Process_2 = Process_1 [t_1=t_2, loc_1=loc_2, failure_1=failure_2, process_1=process_2] endmodule
module Process_3 = Process_1 [t_1=t_3, loc_1=loc_3, failure_1=failure_3, process_1=process_3] endmodule
module Process_4 = Process_1 [t_1=t_4, loc_1=loc_4, failure_1=failure_4, process_1=process_4] endmodule

formula process_1_finishes = (loc_1=crit & t_1=0);
label "process_1_finishes" = process_1_finishes;
formula process_2_finishes = (loc_2=crit & t_2=0);
label "process_2_finishes" = process_2_finishes;
formula process_3_finishes = (loc_3=crit & t_3=0);
label "process_3_finishes" = process_3_finishes;
formula process_4_finishes = (loc_4=crit & t_4=0);
label "process_4_finishes" = process_4_finishes;
module Resources
	user_1: [0..4] init none;
	boost_1: [0..1] init 0;
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_1
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1);
	[tick] user_1=none & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	//self loop when user=process_1
	[tick] user_1=process_1 & !process_1_finishes
		->	true;
	//from user=process_1 to user=none
	[tick] user_1=process_1 & process_1_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_1 to user=process_x (x!=1)
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_1 & process_1_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	[tick] user_1=process_1 & process_1_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_1 & process_1_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_2
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2);
	[tick] user_1=none & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	//self loop when user=process_2
	[tick] user_1=process_2 & !process_2_finishes
		->	true;
	//from user=process_2 to user=none
	[tick] user_1=process_2 & process_2_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_2 to user=process_x (x!=2)
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_2 & process_2_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	[tick] user_1=process_2 & process_2_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_2 & process_2_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_3
	[tick] user_1=none & loc_3=wait
		->	(user_1'=process_3);
	[tick] user_1=none & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	//self loop when user=process_3
	[tick] user_1=process_3 & !process_3_finishes
		->	true;
	//from user=process_3 to user=none
	[tick] user_1=process_3 & process_3_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_3 to user=process_x (x!=3)
	[tick] user_1=process_3 & process_3_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_3 & process_3_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_3 & process_3_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	[tick] user_1=process_3 & process_3_finishes & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//from user=none to user=process_4
	[tick] user_1=none & loc_4=wait
		->	(user_1'=process_4);
	[tick] user_1=none & loc_4=wait
		->	(user_1'=process_4) & (boost_1'=1);
	//self loop when user=process_4
	[tick] user_1=process_4 & !process_4_finishes
		->	true;
	//from user=process_4 to user=none
	[tick] user_1=process_4 & process_4_finishes & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait
		->	(user_1'=none) & (boost_1'=0);
	//from user=process_4 to user=process_x (x!=4)
	[tick] user_1=process_4 & process_4_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_1=wait
		->	(user_1'=process_1) & (boost_1'=0);
	[tick] user_1=process_4 & process_4_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_2=wait
		->	(user_1'=process_2) & (boost_1'=0);
	[tick] user_1=process_4 & process_4_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=1);
	[tick] user_1=process_4 & process_4_finishes & loc_3=wait
		->	(user_1'=process_3) & (boost_1'=0);
	//-------------------------------------------------------------------------------------------------------------------------
	//self loop when user=none
	[tick] user_1=none & loc_1!=wait & loc_2!=wait & loc_3!=wait & loc_4!=wait
		->	true;
endmodule

//every third processor is twice as expensive
const m_1 = 1;
const m_2 = 1;
const m_3 = 2;
const m_4 = 1;
const boost_multiplicator = 3;
rewards "energyGlobal"
	//energy consumption of all the processors
	[tick] loc_1=ncrit: 2*m_1;
	[tick] loc_1=wait: 1*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=0: 3*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=1: 3*m_1*boost_multiplicator;
	[tick] loc_2=ncrit: 2*m_2;
	[tick] loc_2=wait: 1*m_2;
	[tick] loc_2=crit & user_1=process_2 & boost_1=0: 3*m_2;
	[tick] loc_2=crit & user_1=process_2 & boost_1=1: 3*m_2*boost_multiplicator;
	[tick] loc_3=ncrit: 2*m_3;
	[tick] loc_3=wait: 1*m_3;
	[tick] loc_3=crit & user_1=process_3 & boost_1=0: 3*m_3;
	[tick] loc_3=crit & user_1=process_3 & boost_1=1: 3*m_3*boost_multiplicator;
	[tick] loc_4=ncrit: 2*m_4;
	[tick] loc_4=wait: 1*m_4;
	[tick] loc_4=crit & user_1=process_4 & boost_1=0: 3*m_4;
	[tick] loc_4=crit & user_1=process_4 & boost_1=1: 3*m_4*boost_multiplicator;
endrewards

rewards "energyLocal"
	//energy consumption of processor 1 only
	[tick] loc_1=ncrit: 2*m_1;
	[tick] loc_1=wait: 1*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=0: 3*m_1;
	[tick] loc_1=crit & user_1=process_1 & boost_1=1: 3*m_1*boost_multiplicator;
endrewards

rewards "utilityGlobal"
	[tick] loc_1=crit & t_1=0 & !failure_1: 1;
	[tick] loc_2=crit & t_2=0 & !failure_2: 1;
	[tick] loc_3=crit & t_3=0 & !failure_3: 1;
	[tick] loc_4=crit & t_4=0 & !failure_4: 1;
endrewards

rewards "utilityLocal"
	[tick] loc_1=crit & t_1=0 & !failure_1: 1;
endrewards