// eServer Product Line Model - Transaction version (11/06/14)
mdp

const int max_cards = 10;
const int max_fast = 8;

// rack types
const int entry    = 0;
const int advanced = 1;
const int premium  = 2;

// coordination feature types
const int aggressive  = 0;
const int highsavings = 1;
const int balanced    = 2;

// distribution feature types
const int weighted    = 0;
const int round_robin = 1;
const int fast_first  = 2;
const int slow_first  = 3;

// queries
formula time_goal = (ctime = maxtime);

// SLA violation if after the time step, bandwidth cannot be guaranteed
formula slavio    = (nextaction = featstep) & (FCloc=operating) => (maxbndw_active < cbndw);
formula initFeats = (FCloc=cash) & (nextaction=timestep);

// scaling factors
const int max_bandwidth=2400; // maximal bandwidth in MBit/s = 2400 (according to eBond)
const int grid_bandwidth = 10 + ceil(max_bandwidth/100); // grid size of bandwidth in MBit/s
const int max_time = 60*24; // maximal time in minutes = 1 day
const int grid_time = 5; // time interval in minutes data packages are measured = 5 (according to eBond)

// predictor assumes higher bandwidth
const double predictor = 0.1; // 10 % (according to eBond)
const double fpredictor = 0.2; // 20 % prediction for buying/upgrading
const double tprob = 0.9; // expected time for technician: 50 minutes
const int max_cooldown = 30; // cool down timer in minutes before deactivating cards (balanced)

// ---------------------------------------------------
// ----------------------- Model
// ---------------------------------------------------

// first, internal constants adapted from scaling
const int maxbndw  = ceil(max_bandwidth/grid_bandwidth);
const int maxtime  = ceil(max_time/grid_time);
// maximal data size converted into number of blocks according to scaling
const int cooldown = ceil(max_cooldown/grid_time);

// network card features
const int maxfastbndw = ceil(10000/grid_bandwidth);
const int maxslowbndw = ceil(1000/grid_bandwidth);

// feature controller restrictions depending on external feature modules (when to buy or sell cards)
// here: possible to adapt to different feature controllers in the setting
formula cterm = (1+fpredictor)*cbndw;
// buy fast card only if a slow card would be not sufficient as predicted
formula buyfastcond = (cards < maxcards) & (fast < maxfast) & (cterm > (fast*maxfastbndw)+((slow+1)*maxslowbndw));
formula buyslowcond = (cards < maxcards) & (cterm > (fast*maxfastbndw)+(slow*maxslowbndw));
formula upgradecond = (fast < maxfast) & (cards > fast) & (cards = maxcards) & (cterm > (fast*maxfastbndw)+(slow*maxslowbndw));
formula changecond  = (buyfastcond | buyslowcond | upgradecond);

// controls the next step of the system (time - feature - configure)
const int timestep = 0;
const int featstep = 1;
const int confstep = 2;
// some card has been activated by the Coordination Feature
module StepController
  nextaction: [0..2] init timestep;
  
  // time for bandwidth and serving
  [time]    (nextaction  = timestep) -> (nextaction' = featstep);

  // feature controller steps
  [stable]   (nextaction = featstep) -> (nextaction' = confstep);
  [buyfast]  (nextaction = featstep) -> (nextaction' = confstep);
  [buyslow]  (nextaction = featstep) -> (nextaction' = confstep);
  [upgrade] (nextaction = featstep) -> (nextaction' = confstep);
  
  // coordination feature distributes bandwidth and wakes/sets cards to sleep
  [conf]     (nextaction = confstep) -> (nextaction' = timestep);
endmodule

// feature controller locations
const int seed = 0;
const int cash = 7;
const int operating = 8;
formula slow = cards - fast;
module FeatureController
  // coordination feature (strategy to distribute bandwidth to network cards)
  distr : [0..3] init weighted;
  FCloc : [0..operating] init seed;
  type : [0..2] init entry;
  maxcards : [1..max_cards] init 1;
  cards : [1..max_cards] init 1;
  maxfast : [0..max_fast] init 0;
  fast  : [0..max_fast] init 0;
  technician_called : [0..1] init 0;
  coord : [0..2] init balanced;
 
  // seed features, check valid feature combinations
  // seeding coordination strategy
  [seedcoord] (FCloc=seed) -> (FCloc'=1) & (coord' = aggressive);
  [seedcoord] (FCloc=seed) -> (FCloc'=1) & (coord' = highsavings);
  [seedcoord] (FCloc=seed) -> (FCloc'=1) & (coord' = balanced);
  
  // seeding coordination strategy
  [seeddistr] (FCloc=1) -> (FCloc'=2) & (distr' = weighted);
  [seeddistr] (FCloc=1) -> (FCloc'=2) & (distr' = round_robin);
  [seeddistr] (FCloc=1) -> (FCloc'=2) & (distr' = slow_first);
  [seeddistr] (FCloc=1) -> (FCloc'=2) & (distr' = fast_first);
  
  // seeding type of rack
  [seedrack] (FCloc=2) -> (FCloc'=3) & (type' = entry);
  [seedrack] (FCloc=2) -> (FCloc'=3) & (type' = advanced);
  [seedrack] (FCloc=2) -> (FCloc'=3) & (type' = premium);
  
  // seed nic slots (entry, advanced, premium)
  [seedmaxcards] (FCloc=3) & (max_cards >= 1) & (type=entry)-> (FCloc'=4) & (maxcards' = 1);
  [seedmaxcards] (FCloc=3) & (max_cards >= 2) & !(type=premium) -> (FCloc'=4) & (maxcards' = 2);
  [seedmaxcards] (FCloc=3) & (max_cards >= 3) & (type=advanced) -> (FCloc'=4) & (maxcards' = 3);
  [seedmaxcards] (FCloc=3) & (max_cards >= 4) & (type=advanced) -> (FCloc'=4) & (maxcards' = 4);
  [seedmaxcards] (FCloc=3) & (max_cards >= 5) & (type=advanced) -> (FCloc'=4) & (maxcards' = 5);
  [seedmaxcards] (FCloc=3) & (max_cards >= 6) & !(type=entry) -> (FCloc'=4) & (maxcards' = 6);
  [seedmaxcards] (FCloc=3) & (max_cards >= 7) & !(type=entry) -> (FCloc'=4) & (maxcards' = 7);
  [seedmaxcards] (FCloc=3) & (max_cards >= 8) & (type=premium) -> (FCloc'=4) & (maxcards' = 8);
  [seedmaxcards] (FCloc=3) & (max_cards >= 9) & (type=premium) -> (FCloc'=4) & (maxcards' = 9);
  [seedmaxcards] (FCloc=3) & (max_cards >= 10) & (type=premium) -> (FCloc'=4) & (maxcards' = 10);
  
  // seed fast slots
  [seedmaxfast] (FCloc=4) & (max_fast >= 0) & (maxcards >= 0) -> (FCloc'=5) & (maxfast' = 0);
  [seedmaxfast] (FCloc=4) & (max_fast >= 1) & (maxcards >= 1) -> (FCloc'=5) & (maxfast' = 1);
  [seedmaxfast] (FCloc=4) & (max_fast >= 2) & (maxcards >= 2) -> (FCloc'=5) & (maxfast' = 2);
  [seedmaxfast] (FCloc=4) & (max_fast >= 3) & (maxcards >= 3) & (type=premium) -> (FCloc'=5) & (maxfast' = 3);
  [seedmaxfast] (FCloc=4) & (max_fast >= 4) & (maxcards >= 4) & (type=premium) -> (FCloc'=5) & (maxfast' = 4);
  [seedmaxfast] (FCloc=4) & (max_fast >= 5) & (maxcards >= 5) & (type=premium) -> (FCloc'=5) & (maxfast' = 5);
  [seedmaxfast] (FCloc=4) & (max_fast >= 6) & (maxcards >= 6) & (type=premium) -> (FCloc'=5) & (maxfast' = 6);
  [seedmaxfast] (FCloc=4) & (max_fast >= 7) & (maxcards >= 7) & (type=premium) -> (FCloc'=5) & (maxfast' = 7);
  [seedmaxfast] (FCloc=4) & (max_fast >= 8) & (maxcards >= 8) & (type=premium) -> (FCloc'=5) & (maxfast' = 8);
  
  // cards seed (1 <= cards <= max)
  [seedcards] (FCloc=5) & (maxcards >= 1) -> (FCloc'=6) & (cards' = 1);
  [seedcards] (FCloc=5) & (maxcards >= 2) -> (FCloc'=6) & (cards' = 2);
  [seedcards] (FCloc=5) & (maxcards >= 3) -> (FCloc'=6) & (cards' = 3);
  [seedcards] (FCloc=5) & (maxcards >= 4) -> (FCloc'=6) & (cards' = 4);
  [seedcards] (FCloc=5) & (maxcards >= 5) -> (FCloc'=6) & (cards' = 5);
  [seedcards] (FCloc=5) & (maxcards >= 6) -> (FCloc'=6) & (cards' = 6);
  [seedcards] (FCloc=5) & (maxcards >= 7) -> (FCloc'=6) & (cards' = 7);
  [seedcards] (FCloc=5) & (maxcards >= 8) -> (FCloc'=6) & (cards' = 8);
  [seedcards] (FCloc=5) & (maxcards >= 9) -> (FCloc'=6) & (cards' = 9);
  [seedcards] (FCloc=5) & (maxcards >= 10) -> (FCloc'=6) & (cards' = 10);
  
  // select kinds of cards (fast + slow = cards)
  [seedkinds] (FCloc=6) & (cards >= 0) & (maxfast >=0) -> (FCloc'=cash) & (fast' = 0);
  [seedkinds] (FCloc=6) & (cards >= 1) & (maxfast >=1) -> (FCloc'=cash) & (fast' = 1);
  [seedkinds] (FCloc=6) & (cards >= 2) & (maxfast >=2) -> (FCloc'=cash) & (fast' = 2);
  [seedkinds] (FCloc=6) & (cards >= 3) & (maxfast >=3) -> (FCloc'=cash) & (fast' = 3);
  [seedkinds] (FCloc=6) & (cards >= 4) & (maxfast >=4) -> (FCloc'=cash) & (fast' = 4);
  [seedkinds] (FCloc=6) & (cards >= 5) & (maxfast >=5) -> (FCloc'=cash) & (fast' = 5);
  [seedkinds] (FCloc=6) & (cards >= 6) & (maxfast >=6) -> (FCloc'=cash) & (fast' = 6);
  [seedkinds] (FCloc=6) & (cards >= 7) & (maxfast >=7) -> (FCloc'=cash) & (fast' = 7);
  [seedkinds] (FCloc=6) & (cards >= 8) & (maxfast >=8) -> (FCloc'=cash) & (fast' = 8);
  [seedkinds] (FCloc=6) & (cards >= 9) & (maxfast >=9) -> (FCloc'=cash) & (fast' = 9);
  [seedkinds] (FCloc=6) & (cards >= 10) & (maxfast >=10) -> (FCloc'=cash) & (fast' = 10);
  
  // cash for the configuration
  [cash] (FCloc = cash) -> (FCloc' = operating);

   // after seeding, let the time run, which can only be done when the system is operating 
   // call technician to change system configuration
  [conf]   (FCloc = operating) -> true;
  [stable] (FCloc = operating) -> true;
  
  [time] (FCloc = operating) &  (changecond) -> (technician_called' = 1);
  [time] (FCloc = operating) & !(changecond) -> true;
  
  // activate new network card feature
  [buyfast] (FCloc=operating) & (buyfastcond) & (technician_called = 1) 
            -> tprob: (fast'= fast + 1) & (cards' = cards + 1) & (technician_called' = 0) + (1-tprob): true;
  [buyslow] (FCloc=operating) & (buyslowcond) & (technician_called = 1)
            -> tprob: (cards' = cards + 1) & (technician_called' = 0) + (1-tprob): true;
  			
  // upgrade network card feature
  [upgrade] (FCloc=operating) & (upgradecond) & (technician_called = 1) 
            -> tprob: (fast'= fast + 1) & (technician_called' = 0) + (1-tprob): true;
endmodule

// coordination feature to hotplug cards and distribute workload generated from the environment
// pterm guarantees no predictor for aggressive coordination
// incorporates cooldown
formula pterm = (1+predictor*coord/max(1,coord))*cbndw;
formula activeslow = activecards - activefast;
formula maxbndw_active = activefast*maxfastbndw + activeslow*maxslowbndw;
formula maxbndw_possible = fast*maxfastbndw + slow*maxslowbndw;
formula fast_requested = floor(pterm/maxfastbndw);
formula slow_requested = ceil((pterm-fast_requested*maxfastbndw)/maxslowbndw);
formula dist_requested = min(fast,fast_requested)*maxfastbndw + min(slow, slow_requested)*maxslowbndw;
module Coordination
  activefast : [0..max_fast] init 0;
  activecards : [1..max_cards] init 1;
  moreactive : [0..1] init 0;
  
  // activate all cards bought
  [cash] true -> (activecards' = cards) & (activefast' = fast);
  
  // assume that slow cards are always cheaper
  // no cooldown -> switch arbitrarily
  [conf] (dist_requested = 0) -> (activecards' = 1) & (activefast' = ((fast > 0) & (slow = 0) ? 1 : 0)) & (moreactive' = 0);
  [conf] (dist_requested >= pterm) & (pterm > 0) & (min(fast,fast_requested)*maxfastbndw + min(slow, slow_requested)*maxslowbndw > maxbndw_active) -> 
        (activefast' = min(fast,fast_requested)) & 
        (activecards' = min(fast,fast_requested) + min(slow, slow_requested)) & 
        (moreactive' = 1);
  [conf] (dist_requested >= pterm) & (pterm > 0) & !(min(fast,fast_requested)*maxfastbndw + min(slow, slow_requested)*maxslowbndw > maxbndw_active) -> 
        (activefast' = (cd > 0 ? activefast : min(fast,fast_requested))) & 
        (activecards' = (cd > 0 ? activecards : min(fast,fast_requested) + min(slow, slow_requested))) & 
        (moreactive' = 0);
  // not enough small cards? take one additional fast card and deactivate all slow ones!
  [conf] (dist_requested < pterm) & (dist_requested > 0) & (fast > fast_requested) & ((fast_requested+1)*maxfastbndw > maxbndw_active) ->
        (activefast' = fast_requested+1) & (activecards' = fast_requested+1) & (moreactive' = 1);
  [conf] (dist_requested < pterm) & (dist_requested > 0) & (fast > fast_requested) & !((fast_requested+1)*maxfastbndw > maxbndw_active) -> 
        (activefast' = (cd > 0 ? activefast : fast_requested+1)) & (activecards' = (cd > 0 ? activecards : fast_requested+1)) & (moreactive' = 0);
  //not enough cards at all -> save your ass by activating everything
  [conf] (dist_requested < pterm) & (min(fast,fast_requested+1)*maxfastbndw < pterm) & (dist_requested > 0) -> (activefast' = fast) & (activecards' = cards) & (moreactive' = (maxbndw_possible > maxbndw_active ? 1 : 0));
endmodule

module Timer
  ctime: [0..maxtime] init 0;
  cd: [0..cooldown] init 0;
  
  // time query - increase ctime until maxtime is reached
  // some card has been activated => cooldown time is set for the balanced coordination
  [time] (coord = balanced) & (moreactive = 1) -> 
         (ctime' = mod(ctime,maxtime)+1) & (cd' = cooldown);
  // no card has been activated => cooldown time is decreased for the balanced coordination
  [time] (coord = balanced) & !(moreactive = 1) -> 
         (ctime' = mod(ctime,maxtime)+1) & (cd' = max(0,cd-1));
  // the balanced coordination feature is not activated => only decrease timer
  [time] !(coord = balanced) -> (ctime' = mod(ctime,maxtime)+1);
endmodule
  
// environment requests bandwidth to be met by the eServer
formula uniprob = 1/9;
formula variance = maxbndw/30;
formula average_morning=variance*2+   ctime/(maxtime/2 )*(maxbndw-variance*2);
formula average_evening=variance*2+(2-ctime/(maxtime/2))*(maxbndw-variance*2);
module Bandwidth
  cbndw : [0..maxbndw] init 1;
 
  [time] ctime<(maxtime/2)  -> 	
                    uniprob:(cbndw'=max(0,min(maxbndw,floor(average_morning+2*variance)))) + 
                    2*uniprob:(cbndw'=max(0,min(maxbndw,floor(average_morning+1*variance)))) +
                    3*uniprob:(cbndw'=floor(average_morning)) +
                    2*uniprob:(cbndw'=max(0,min(maxbndw,floor(average_morning-1*variance)))) +
                    uniprob:(cbndw'=max(0,min(maxbndw,floor(average_morning-2*variance)))); 
  [time] ctime>=(maxtime/2) ->
                    uniprob:(cbndw'=max(0,min(maxbndw,floor(average_evening-2*variance)))) + 
                    2*uniprob:(cbndw'=max(0,min(maxbndw,floor(average_evening-1*variance)))) +
                    3*uniprob:(cbndw'=floor(average_evening)) +
                    2*uniprob:(cbndw'=max(0,min(maxbndw,floor(average_evening+1*variance)))) +
                    uniprob:(cbndw'=max(0,min(maxbndw,floor(average_evening+2*variance))));
endmodule

// ---------------------------------------------------
// ------------------------- Cost Model / Rewards
// ---------------------------------------------------

// norming factor to regulate precision of energy values concerning time steps
const double nf = 1.349;
// energy consumption of 1 GBit card in Watts
const double idleCosts1GBit    = 1.349/nf;
const double offsetCosts1GBit  = 1.67015384615/nf;
const double activeCosts1GBit  = 1.892/nf;
// minimal bandwidth after which starting to be constant for 1 GBit/s NIC
const int const_point = 540; // in MBit/s
formula constpoint = const_point/grid_bandwidth;

// energy consumption of 10 GBit card in Watts
const double idleCosts10GBit   = 7.856713824333/nf;
const double activeCosts10GBit = 8.064233679099/nf;

// distributed workload according to distribution feature
formula workload = min(1, cbndw/maxbndw_active); // requires maxbndw_active > 0!
formula slow_bndw = min(maxslowbndw, (activeslow = 0 ? 0 :
                    (distr = weighted ? workload*maxslowbndw : 
                    (distr = round_robin ? cbndw/activecards :
                    (distr = fast_first ? max(0, (cbndw-activefast*maxfastbndw)/activeslow) :
                    cbndw/activeslow)))));
formula fast_bndw = min(maxfastbndw, (activefast = 0 ? 0 :
                    max(0, (cbndw-activeslow*slow_bndw)/activefast )));

// to norm the energy to Watt hours, multiply with (100*grid_time/max_time)
rewards "energy"
  [conf] (workload = 0): floor(activefast*idleCosts10GBit + activeslow*idleCosts1GBit);
  [conf] (slow_bndw < constpoint) & (cbndw > 0): 
        floor(activefast*(idleCosts10GBit  + (activeCosts10GBit - idleCosts10GBit)/maxfastbndw*fast_bndw) + 
        activeslow*(offsetCosts1GBit + (activeCosts1GBit  - offsetCosts1GBit)/constpoint*slow_bndw));
  [conf] (slow_bndw >= constpoint) : 
        floor(activefast*(idleCosts10GBit  + (activeCosts10GBit - idleCosts10GBit)/maxfastbndw*fast_bndw) + 
        activeslow*(activeCosts1GBit));
endrewards

// number of SLA violations (for percentage, multiply with 100/maxtime)
rewards "sla"
  [stable]  slavio : 1;
  [buyfast] slavio : 1;
  [buyslow] slavio : 1;
  [upgrade] slavio : 1;
endrewards

rewards "minutes"
  [conf] true : grid_time;
endrewards
