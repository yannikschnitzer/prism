mdp
const int N=3;
const int rows = 4;
const double p=0.2; // with probability p, a move to a neighboring state state occurs due to seeing and control noise
const double flat_p=0.22;

module robot
	//define robot position
	r:[1..rows] init 1; //grid row
	c:[1..N] init 2; //grid column
	flat: bool init false;

	// go to the terminal state when hitting an obstacle
	[obstacle] (r=2 & c=2) | (r=3 & c=2)  -> (r'=N) & (c'=2);

	// transitions
	[east] ( c< N | c=N) & !((r=2 & c=2) | (r=3 & c=2)  )-> p:(r'=r) + (1-p): (c'=min(c+1, N));
	[south] (c=1) & (r<N | r=N) & !((r=2 & c=2) | (r=3 & c=2))-> (1-(p+flat_p)):(r'=min(r+1, N)) + p: (c'=c) + flat_p: (c'=c) & (flat'=!flat);
	[south] (c=3) & (r<N | r=N) & !((r=2 & c=2) | (r=3 & c=2) )-> (1-p):(r'=min(r+1, N)) + p: (c'=c);
	[west]  (c>1 | c=1) & !((r=2 & c=2) | (r=3 & c=2) )-> p:(r'=r) + (1-p): (c'=max(c-1, 1));
	[north] (c=1) & (r=1 | r>1) & !((r=2 & c=2) | (r=3 & c=2))-> (1-(p+flat_p)):(r'=max(r-1, 1)) + p: (c'=c) + flat_p: (c'=c) & (flat'=!flat);
	[north] (c=3) & (r=1 | r>1) & !((r=2 & c=2) | (r=3 & c=2))-> (1-p):(r'=max(r-1, 1)) + p: (c'=c);

	// terminal state self-loop to avoid deadlock
	[] r=N & c=2-> true;
endmodule

label "goal" = r=N & c=2;
label "obs" = flat | (r=2 & c=2) | (r=3 & c=2);

rewards
	[east] true : 1;
	[south]  c=1 & !flat : 1;
	[south]  c=1 & flat : 5;
	[south]  c=3 | c=4 : 3;
	[west] true : 1;
	[north] c=1 & !flat: 1;
	[north] c=1 & flat: 5;
	[north] c=3 | c=4: 3;
	[obstacle] true : 30;
endrewards
